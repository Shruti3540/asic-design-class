<details>
  <summary>LAB 1: Writing a C program and comparing the outputs compiled with both GCC and the RISC-V compiler. </summary>

# **LAB SESSION 1:**

### **Task 1 : Compiling a C program using GCC and RISC-V**

**STEP 1:** Create a file in editor in Linux environment

![s0](https://github.com/user-attachments/assets/2579e3bb-2e9c-4806-8f93-6601cff88121)

**STEP 2:** Write your code in leafpad and save it

![s1](https://github.com/user-attachments/assets/05d04e05-9b15-4e7c-9616-d45edaaf0f4f)

**STEP 3:** Compile your code using gcc compiler in the terminal window

![s2](https://github.com/user-attachments/assets/2568a685-d390-4f7c-a1e1-910578236ce4)

**STEP 4:** Once you've finished compiling your code, the next step is to run the executable file in your terminal to view its output.

![s3](https://github.com/user-attachments/assets/854f0cdd-09a1-45a6-b5eb-9f62a2600b42)

**Final Output along with Code:**

![s4](https://github.com/user-attachments/assets/21afb510-b79e-4b97-a0eb-ba57cc9d2d26)

### **Task 2 : Compile and run a C program using a RISC-V compiler, optimizing the compilation with -O1 and -Ofast**

**STEP 1:** Write a c program sum1ton on leafpad and save it. Enter a command cat sum1ton.c to view its contents in the terminal.

![1](https://github.com/user-attachments/assets/bfcc7bcd-15aa-4342-870f-fa317551bd25)

**STEP 2:** Compile the C program using the RISC-V compiler with **-O1** optimization.

![2](https://github.com/user-attachments/assets/15abca9b-87b6-497d-adcf-1ae24bf3ea99)

**STEP 3:** Now we enter a command that is used to display information about object files. Since that is long list we use less in the command.

![4a](https://github.com/user-attachments/assets/88ad32f1-b2d0-4638-a69a-4fc01eea9023)

**STEP 4:** We are interested in the main section of the information displayed. Therefore we type main and get the following information.

![3](https://github.com/user-attachments/assets/e6cd9366-a5df-4b40-8b4b-da3129cbd927)

**OBSERVATION 1: There are 14 lines of opcode in main section** 

**STEP 5:** Now again compile the same program using RISC - V compiler but now optimise the compilation using **-Ofast** optimization.

![3b](https://github.com/user-attachments/assets/adad17db-ca14-45f4-b8e4-3077b3c09c05)

**STEP 6:** Similar to the step 3 we enter a command and get another list. The main section of ofast looks as shown in the image.

![4](https://github.com/user-attachments/assets/858d515d-f8b5-49b7-af2a-79da66d20a9e)

**OBSERVATION 2: There are 11 lines of opcode in main section**

**Conclusion: We get an optimized compilation using -Ofast.**

</details>



***



<details>
  <summary>LAB 2: Running the object file generated by the RISC-V compiler in the Spike Simulator and debugging with the Spike Debugger.</summary>

# **LAB SESSION 2:**

### **Task 1 : To compile the Object dump file and verify the output with the GCC output from Lab 1.**

**STEP 1:** Compile sum1ton.c (C source file) into sum1ton.o (Object file) for RISC-V with -Ofast optimization.
``` bash
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sumton.o sumton.c
```

**STEP 2:** Get the Object dump using following command.
``` bash
riscv64-unknown-elf-objdump -d sumton.o | less
```
We get the following output:

![2a](https://github.com/user-attachments/assets/3a431303-1d62-4135-9d6d-0b747380d6a6)

**STEP 3:** Execute the compiled sum1ton.o (object file) using Spike.
``` bash
spike pk sumton.o
```
We get the following output:

![2b](https://github.com/user-attachments/assets/643b5ae2-305a-4336-ac65-668a8b5a052d)

### **Task 2 : To debug the main function and observe register values**

**STEP 1:** Run the assembly code in sum1ton.o on the Spike simulator in debug mode.
``` bash
spike -d pk sumton.o
```
To execute until start of main use following command:
```bash
until pc 0 100b0
```
![2c](https://github.com/user-attachments/assets/3411e913-96df-454e-b13f-4f0c434f119c)

**STEP 2:** Run the following Commands and Observe the Register Values.
```bash
reg 0 a2
reg 0 sp
```

**FINAL OUTPUT:**

<img width="715" alt="Screenshot 2024-07-21 234052" src="https://github.com/user-attachments/assets/0191ffa6-1ef5-45de-90b6-aefbdf1f53ef">

</details>



***



<details>
  <summary>LAB 3: All about RISC-V instructions: Their types, Decoding, Simulation.</summary>

# **LAB SESSION 3:** 

### **TASK 1: Identifying Instruction Format**
The task is to identify different types of instructions based on the provided guidelines. This identification is done using a 32-bit code, with each instruction type having its unique format.

### RISC-V Instruction Formats

Instruction formats in RISC-V act as a 'contract' between the assembly language and the hardware. When an assembly instruction is executed, the hardware understands exactly what to do based on this contract. Each instruction type has a specific format, defined by a series of 0s and 1s, that includes details such as the type of operation and the location of data.

#### 1) R-Type (Register)
 R-type instructions handle all arithmetic and logical operations involving three registers. 
 
 The format includes fields for two source registers, one destination register, a function code, and an opcode.

 Instruction format is as follows:

<img width="538" alt="Screenshot 2024-07-28 170104" src="https://github.com/user-attachments/assets/ae16efea-a976-44c2-9ca1-7078d5814a00">

- **funct7 (7 bits):** Function code for additional instruction differentiation.
- **rs2 (5 bits):** Second source register.
- **rs1 (5 bits):** First source register.
- **funct3 (3 bits):** Function code for primary instruction differentiation.
- **rd (5 bits):** Destination register.
- **opcode (7 bits):** Basic operation code for R-type instructions (0110011 for integer operations).

**Examples:** ADD, SUB, OR, XOR

#### 2) I-Type (Immediate)
These instructions perform arithmetic with immediate values, load operations, and certain branch instructions.

I-type instructions involve operations with an immediate value and one or two registers. 

Instruction format is as follows:

<img width="528" alt="Screenshot 2024-07-28 171319" src="https://github.com/user-attachments/assets/0a532019-7b7c-4b33-a5ee-f90a56420177">

- **immediate (12 bits):** Immediate value used for operations.
- **rs1 (5 bits):** Source register.
- **funct3 (3 bits):** Function code for instruction differentiation.
- **rd (5 bits):** Destination register.
- **opcode (7 bits):** Basic operation code for I-type instructions.

#### 3) S-Type (Store)
S-type instructions are used for store operations, where data is stored from a register into memory. 

The format includes fields for two source registers, an immediate value determining the memory offset, a function code, and an opcode.

Instruction format is as follows:

<img width="522" alt="Screenshot 2024-07-28 171843" src="https://github.com/user-attachments/assets/44fee5c1-e67a-42d3-a147-6a634aa6b965">

- **imm[11:5] (7 bits):** Upper 7 bits of the immediate value.
- **rs2 (5 bits):** Second source register (contains the data to be stored).
- **rs1 (5 bits):** First source register (base address register).
- **funct3 (3 bits):** Function code for instruction differentiation.
- **imm[4:0] (5 bits):** Lower 5 bits of the immediate value.
- **opcode (7 bits):** Basic operation code for S-type instructions.

#### 4) B-Type (Branch)
B-type instructions are used for conditional branch operations.

These instructions alter the flow of execution based on comparisons between two registers.

Instruction format is as follows:

<img width="520" alt="Screenshot 2024-07-28 171920" src="https://github.com/user-attachments/assets/4a11d921-b87a-435d-a5e2-2406f7071e11">

- **imm[12] (1 bit):** The 12th bit of the immediate value.
- **imm[10:5] (6 bits):** The 10th to 5th bits of the immediate value.
- **rs2 (5 bits):** Second source register.
- **rs1 (5 bits):** First source register.
- **funct3 (3 bits):** Function code for instruction differentiation.
- **imm[4:1] (4 bits):** The 4th to 1st bits of the immediate value.
- **imm[11] (1 bit):** The 11th bit of the immediate value.
- **opcode (7 bits):** Basic operation code for B-type instructions.

#### 5) U-Type (Upper Immediate)
U-type instructions handle operations involving large immediate values, typically for loading upper immediate values or computing addresses.

Instruction format is as follows:

<img width="518" alt="Screenshot 2024-07-28 171959" src="https://github.com/user-attachments/assets/0a5238e0-9a70-4944-911e-97a7e925e49b">

- **immediate[31:12] (20 bits):** The upper 20 bits of the immediate value.
- **rd (5 bits):** Destination register.
- **opcode (7 bits):** Operation code for U-type instructions.

The immediate value is stored in the upper 20 bits of a 32-bit word, with the lower 12 bits set to zero when used in calculations.

#### 6) J-Type (Jump)
J-type instructions are used for jump operations, allowing for altering the program control flow by jumping to a specified address.

These are typically used for unconditional jumps, such as calling functions or implementing loops.

Instruction format is as follows:

<img width="521" alt="Screenshot 2024-07-28 172109" src="https://github.com/user-attachments/assets/e158ade7-6748-4ba0-9adf-84b5f67d2410">

- **imm[20] (1 bit):** The 20th bit of the immediate value.
- **imm[10:1] (10 bits):** The 10th to 1st bits of the immediate value.
- **imm[11] (1 bit):** The 11th bit of the immediate value.
- **imm[19:12] (8 bits):** The 19th to 12th bits of the immediate value.
- **rd (5 bits):** Destination register where the return address is stored.
- **opcode (7 bits):** Operation code for J-type instructions.

### **TASK 2: Decoding each Instruction Provided**

1) **ADD r8, r9, r10**
  - Opcode: 0110011
  - rd = r8 = 01000
  - rs1 = r9 = 01001
  - rs2 = r10 = 01010
  - funct3: 000
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_01010_01001_000_01000_0110011`

2) **SUB r10, r8, r9**
  - Opcode: 0110011
  - rd = r10 = 01010
  - rs1 = r8 = 01000
  - rs2 = r9 = 01001
  - funct3: 000
  - funct7: 0100000
  - **R-Type**
  - 32-bit Instruction: `0100000_01001_01000_000_01010_0110011`

3) **AND r9, r8, r10**
  - Opcode: 0110011
  - rd = r9 = 01001
  - rs1 = r8 = 01000
  - rs2 = r10 = 01010
  - funct3: 111
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_01010_01000_111_01001_0110011`

4) **OR r8, r9, r5**
  - Opcode: 0110011
  - rd = r8 = 01000
  - rs1 = r9 = 01001
  - rs2 = r5 = 00101
  - funct3: 110
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_00101_01001_110_01000_0110011`

5) **XOR r8, r8, r4**
  - Opcode: 0110011
  - rd = r8 = 01000
  - rs1 = r8 = 01000
  - rs2 = r4 = 00100
  - funct3: 100
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_00100_01000_100_01000_0110011`

6) **SLT r0, r1, r4**
  - Opcode: 0110011
  - rd = r0 = 00000
  - rs1 = r1 = 00001
  - rs2 = r4 = 00100
  - funct3: 010
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_00100_00001_010_00000_0110011`

7) **ADDI r2, r2, 5**
  - Opcode: 0010011
  - rd = r2 = 00010
  - rs1 = r2 = 00010
  - immediate: 000000000101
  - funct3: 000
  - **I-Type**
  - 32-bit Instruction: `000000000101_00010_000_00010_0010011`

8) **SW r2, r0, 4**
  - Opcode: 0100011
  - rs2 = r2 = 00010
  - rs1 = r0 = 00000
  - imm[11:5]: 0000000
  - imm[4:0]: 00100
  - funct3: 010
  - **S-Type**
  - 32-bit Instruction: `0000000_00010_00000_010_00100_0100011`

9) **SRL r6, r1, r1**
  - Opcode: 0110011
  - rd = r6 = 00110
  - rs1 = r1 = 00001
  - rs2 = r1 = 00001
  - funct3: 101
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_00001_00001_101_00110_0110011`

10) **BNE r0, r0, 20**
  - Opcode: 1100011
  - rs1 = r0 = 00000
  - rs2 = r0 = 00000
  - imm[12|10:5|4:1|11]: 0000000 00000 00010 0
  - funct3: 001
  - **B-Type**
  - 32-bit Instruction: `0000000_00000_00000_001_00010_0000000_1100011`

11) **BEQ r0, r0, 15**
  - Opcode: 1100011
  - rs1 = r0 = 00000
  - rs2 = r0 = 00000
  - imm[12|10:5|4:1|11]: 0000000 00000 00001 1
  - funct3: 000
  - **B-Type**
  - 32-bit Instruction: `0000000_00000_00000_000_00001_0000000_1100011`

12) **LW r3, r1, 2**
  - Opcode: 0000011
  - rd = r3 = 00011
  - rs1 = r1 = 00001
  - immediate: 000000000010
  - funct3: 010
  - **I-Type**
  - 32-bit Instruction: `000000000010_00001_010_00011_0000011`
 
13) **SLL r5, r1, r1**
  - Opcode: 0110011
  - rd = r5 = 00101
  - rs1 = r1 = 00001
  - rs2 = r1 = 00001
  - funct3: 001
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_00001_00001_001_00101_0110011`
 
### **TASK 3: Executing assembly instructions based on a provided Verilog code within a RISC-V processor.**
Firstly for the provided verilog code there is some variations in the ISA followed by RISCV and the hardcoded ISA. The differences are shown in the table below:

| Operation            | Standard RISC-V ISA | Hardcoded ISA  |
|----------------------|----------------------|----------------|
| ADD R6, R2, R1       | 32'h00110333         | 32'h02208300   |
| SUB R7, R1, R2       | 32'h402083b3         | 32'h02209380   |
| AND R8, R1, R3       | 32'h0030f433         | 32'h0230a400   |
| OR R9, R2, R5        | 32'h005164b3         | 32'h02513480   |
| XOR R10, R1, R4      | 32'h0040c533         | 32'h0240c500   |
| S#LT R1, R2, R4       | 32'h0045a0b3         | 32'h02415580   |
| ADDI R12, R4, 5      | 32'h004120b3         | 32'h00520600   |
| BEQ R0, R0, 15       | 32'h00000f63         | 32'h00f00002   |
| SW R3, R1, 2         | 32'h0030a123         | 32'h00209181   |
| LW R13, R1, 2        | 32'h0020a683         | 32'h00208681   |
| SRL R16, R14, R2     | 32'h0030a123         | 32'h00271803   |
| SLL R15, R1, R2      | 32'h002097b3         | 32'h00208783   |

Now for the custom instructions provided:

| Operation             | RISC-V ISA  | Bit Pattern (RISC-V)              |
|-----------------------|-------------|-----------------------------------|
| ADD r1, r2, r3        | 32'h006100B3 | 0000000 00110 00010 000 00001 0110011 |
| SUB r3, r1, r2        | 32'h40208333 | 0100000 00010 00001 000 00110 0110011 |
| AND r2, r1, r3        | 32'h0230a400 | 0000000 00011 00001 111 00010 0110011 |
| OR r8, r2, r5         | 32'h0030F133 | 0000000 00101 00010 110 01000 0110011 |
| XOR r8, r1, r4        | 32'h0040C433 | 0000000 00100 00001 100 01000 0110011 |
| SLT r10, r2, r4       | 32'h00412633 | 0000000 00100 00010 010 01100 0110011 |
| ADDI r12, r3, 5       | 32'h00508313 | 000000000101 00001 000 00110 0010011  |
| SW r3, r1, 4          | 32'h00205223 | 0000000 00100 00001 010 0100 0100011  |
| SRL r16, r11, r2      | 32'h0025D833 | 0000000 00010 01011 101 10000 0110011 |
| BNE r0, r1, 20        | 32'h02101A63 | 0 000001 00001 00000 001 1010 0 1100011 |
| LW r13, r11, 2        | 32'h000969A1 | 000000000010 01011 010 01101 00001 |
| SLL r15, r11, r2      | 32'h002597B3 | 0000000 00010 01011 001 01111 0110011 |
| BEQ r0, r0, 15        | 32'h00000F63 | 0 000000 00000 00000 000 1111 0 1100011 |

### **TASK 4: RISC-V Functional Simulation**

1. Compile the Verilog Code using the below command

 ```bash
 iverilog -o iiitb_rv32i iiitb_rv32i.v iiitb_rv32i_tb.v
 ```
2. Run this command to execute the test bench and generate a .vcd file:
 ```bash
  vvp iiitb_rv32i_tb
 ```
3. View the Test Bench in GTKWave:
```bash
gtkwave iiitb_rv32i.vcd
```

### The waveforms for the hardcoded instruction is given below:

`ADD R6, R2, R1`

![Screenshot from 2024-07-30 00-26-20](https://github.com/user-attachments/assets/308c3123-c22e-44d4-af43-2412cd0021ba)

`SUB R7, R1, R2`

![Screenshot from 2024-07-30 00-29-19](https://github.com/user-attachments/assets/d0e289ef-0037-4202-9934-c56d78c5e62c)

`AND R8, R1, R3`

![Screenshot from 2024-07-30 00-29-51](https://github.com/user-attachments/assets/a69ed3f1-e370-4440-9d4f-8b6d9efb12bd)

`OR R9, R2, R5`

![Screenshot from 2024-07-30 00-30-35](https://github.com/user-attachments/assets/e471d776-92ae-4e79-9af2-8fcb53fa4fd3)

`XOR R10, R1, R4`

![Screenshot from 2024-07-30 00-31-15](https://github.com/user-attachments/assets/384552c6-5cae-4325-ad13-235590b502d2)

`SLT R1, R2, R4`

![Screenshot from 2024-07-30 00-32-31](https://github.com/user-attachments/assets/d759ccb4-84cf-4921-b55e-1a7af6604074)

`ADDI R12, R4, 5`

![Screenshot from 2024-07-30 00-33-15](https://github.com/user-attachments/assets/7aa8f1eb-63d6-492a-89d1-55f5c546cae8)

`BEQ R0, R0, 15`

![Screenshot from 2024-07-30 00-35-47](https://github.com/user-attachments/assets/90427858-6048-4d6d-ab50-b20ebf70c6b0)

`SW R3, R1, 2`

![Screenshot from 2024-07-30 00-34-39](https://github.com/user-attachments/assets/4fd987cf-0039-4be6-86ab-faf7d4b06533)

`LW R13, R1, 2`

![Screenshot from 2024-07-30 00-35-14](https://github.com/user-attachments/assets/d0d03073-268e-41ec-bf8b-de4d25e06a39)


### Observation:

We observe a variation between bit pattern of RISCV code and hardcoded ISA.


</details>


***


<details>
  <summary>LAB 4: Writing a C program for a simple application that can be compiled using GCC and RISC-V GCC. </summary>

# **LAB SESSION 4:**
In this lab, we are repeating the steps performed in the previous labs, but for a different application.

**APPLICATION : ELEVATOR CONTROLLER** 

The code provided is a simple implementation of an elevator controller in C. It simulates the basic operations of an elevator, including moving between floors, handling user input for destination floors, and providing feedback on the elevator's status. This program models how an elevator tracks its current position, responds to user commands, and manages directional movement to reach the desired floor, making it a fundamental example of how elevator systems work in real-world applications.

### Task 1 : Writing a C code and compiling the program using GCC (O0).

**STEP 1:** Write a C code for the desired application.

```
#include <stdio.h>

int main() {
    int current_floor = 0;
    int destination_floor;

    while (1) {
        printf("Current Floor: %d\n", current_floor);
        printf("Enter the destination floor (0-9): ");
        scanf("%d", &destination_floor);

        if (destination_floor < 0 || destination_floor > 9) {
            printf("Invalid floor!\n");
            continue;
        }

        if (destination_floor > current_floor) {
            printf("Going up...\n");
            for (int i = current_floor; i <= destination_floor; i++) {
                printf("Floor %d\n", i);
            }
        } else if (destination_floor < current_floor) {
            printf("Going down...\n");
            for (int i = current_floor; i >= destination_floor; i--) {
                printf("Floor %d\n", i);
            }
        } else {
            printf("Already at floor %d\n", current_floor);
        }

        current_floor = destination_floor;
    }
    return 0;
}

```

**STEP 2 :** Compile your code using gcc compiler in the terminal window.

```
gcc ElevatorController.c
```

**STEP 3 :** Run the executable file in your terminal to view its output.

![lab 4 1](https://github.com/user-attachments/assets/74ef10db-a01c-42b3-b45a-8a52b34b0b97)

### Task 2 :  Compile and run a C program using a RISC-V compiler, optimizing the compilation with -O1 (O1).

**STEP 1:** Compile using O1 compiler flag use the following command:

```
riscv64-unknown-elf-gcc -O1 -mabi=lp64i -march=rv64i -o ElevatorControllerO1 ElevatorController.c
```

**STEP 2:** ElevatorControllerO1 is the output file after compilation. Output can be seen using the command:

```
spike pk ElevatorControllerO1
```

**STEP 3:** The output is :

![lab 4 2](https://github.com/user-attachments/assets/aa775e37-8023-4652-b0e8-0a2b4093c615)

### Comparing the gcc compiled output and the risc-v output:

![lab 4 3](https://github.com/user-attachments/assets/957ee189-b719-47c9-af6a-0bfb8c4a31b6)

### **OBSERVATION : The output from both the compilation techniques results to same value for similar inputs given.**
## Hence O0=O1


</details>


***

<details>
  <summary>LAB 5: Digital Logic with TL-Verilog using Makerchip (Day 3) </summary>

# **LAB SESSION 5:** 

### Introduction to Makerchip and TL-Verilog:

Makerchip is an online platform and integrated development environment (IDE) that simplifies the design and simulation of digital circuits using TL-Verilog and traditional Verilog. It offers a user-friendly, accessible interface where users can create, simulate, and visualize hardware designs directly in a web browser, eliminating the need for any software installation.

TL-Verilog is a modern hardware description language designed to simplify and accelerate digital design by reducing the verbosity and complexity commonly associated with traditional hardware languages like Verilog and VHDL. 

TL-Verilog enhances design efficiency by adding powerful constructs for pipelines and transactions, making it easier to develop complex digital circuits.

## Combinational Circuit:

### 1. Combinational Calculator :-
The calculator performs four fundamental arithmetic operations: addition, subtraction, multiplication, and division. 

CODE: 
```
$val1[31:0] = $rand1[3:0];
$val2[31:0] = $rand2[3:0];

$sum[31:0]  = $val1[31:0] + $val2[31:0];
$diff[31:0] = $val1[31:0] - $val2[31:0];
$prod[31:0] = $val1[31:0] * $val2[31:0];
$quot[31:0] = $val1[31:0] / $val2[31:0];

$out[31:0]  = $sel[1] ? ($sel[0] ? $quot[31:0] : $prod[31:0])
                      : ($sel[0] ? $diff[31:0] : $sum[31:0]);
```

OUTPUT WAVEFORM:
![5a](https://github.com/user-attachments/assets/f91de9fc-361d-4fb1-8db5-27891a65ed28)

## Sequential Circuit:

A sequential circuit is a type of digital circuit that uses memory components to retain data, enabling it to generate outputs based on both the current inputs and the circuit's prior state.Sequential circuits rely on feedback loops and storage elements like flip-flops or registers to keep track of their internal state over time. This internal state, combined with the present input, influences the circuit's behavior, allowing it to perform tasks that require a history of previous inputs or operations, such as counting, storing data, or sequencing events.

### 2. Free Running Counter :-
The following code acts as a simple free running counter with a reset value of 0. The counter adds integer 1 to $count at each clock. 

CODE:
```
$reset = *reset;
$count[31:0] = $reset ? 0 : (>>1$count + 1);
```

OUTPUT WAVEFORM:
![5b](https://github.com/user-attachments/assets/9b707c4c-b1ed-497d-a4bf-690c29fb694e)

### 3. Sequential Calculator:-
In real world scenarios calculators typically retain the previous result and apply it in the next operation. The sequential calculator follows this approach by feeding the output back as the input for the subsequent calculation. 

CODE:
```
$val1[31:0] = >>1$out;
$val2[31:0] = $rand[3:0]; 
$sum[31:0] =  $val1[31:0] +  $val2[31:0];
$diff[31:0] =  $val1[31:0] -  $val2[31:0];
$prod[31:0] =  $val1[31:0] *  $val2[31:0];
$quot[31:0] =  $val1[31:0] /  $val2[31:0];
$out[31:0] = $reset ? 32'h0 : ($choose[1] ? ($choose[0] ? $quot : $prod):($choose[0] ? $diff : $sum));
```

OUTPUT WAVEFORM:
![5c](https://github.com/user-attachments/assets/d7e8fae2-cdc1-4970-9b6c-cd95bd46a12a)

## Pipelined Logic:

In Transaction-Level Verilog (TL-Verilog), pipelined logic is expressed using constructs that represent data flow through design stages, with each stage corresponding to a clock cycle. This method simplifies sequential logic modeling, as stages automatically manage state propagation. TL-Verilog's pipeline notation allows designers to describe complex operations focused on transaction flow, improving design clarity and maintainability.

### 4. Cycle Calculator:-

![Screenshot 2024-08-22 003543](https://github.com/user-attachments/assets/98339d1f-ea39-49a2-ac3b-3d172ecd4916)

CODE:
```
|calc
      @1
         $clk_tan = *clk;
         $reset = *reset;
         
         
         $val1[31:0] = >>2$out[31:0];
         $val2[31:0] = $rand2[3:0];
         $op[1:0] = $rand3[1:0];
   
         $sum[31:0] = $val1[31:0] + $val2[31:0];
         $diff[31:0] = $val1[31:0] - $val2[31:0];
         $prod[31:0] = $val1[31:0] * $val2[31:0];
         $quot[31:0] = $val1[31:0] / $val2[31:0];
         
         $num = $reset ? 0 : >>1$num+1;
      @2   
         $out[31:0] = ($reset|!$num) ? 32'b0 : (($op[1:0]==2'b00) ? $sum :
                                       ($op[1:0]==2'b01) ? $diff :
                                          ($op[1:0]==2'b10) ? $prod : $quot);
```

OUTPUT WAVEFORM:
![5d](https://github.com/user-attachments/assets/34b2ca1d-b62c-4cde-a8b9-bcc4efb76cc4)

## Validity:

In TL-Verilog, validity is a key concept used to manage data flow through pipelines. It helps ensure that operations are only performed on valid data and prevents the unnecessary processing of invalid or stale data. This concept is essential in pipelined designs, where operations are spread across multiple clock cycles.

### 5. Validity-Cycle Calculator:-

CODE:
```
|calc
    @0
        $clk_tan = *clk;
        $reset = *reset;
    @1 
        $valid = $reset ? 0 : >>1$valid+1;
        $valid_or_reset = $valid || $reset;  
    ?$valid   
        @1          
          $val1[31:0] = >>2$out[31:0];
          $val2[31:0] = $rand2[3:0];
          $op[1:0] = $rand3[1:0];
        
          $sum[31:0] = $val1[31:0] + $val2[31:0];
          $diff[31:0] = $val1[31:0] - $val2[31:0];
          $prod[31:0] = $val1[31:0] * $val2[31:0];
          $quot[31:0] = $val1[31:0] / $val2[31:0];            
    @2   
       $out[31:0] = $valid_or_reset ? (($op[1:0]==2'b00) ? $sum :
                                           ($op[1:0]==2'b01) ? $diff :
                                              ($op[1:0]==2'b10) ? $prod : $quot) : >>1$out[31:0];
```

OUTPUT WAVEFORM:
![5e](https://github.com/user-attachments/assets/62b845ca-ed50-4feb-9f3f-937146113d69)

</details>


***

<details>
  <summary>LAB 6: Basic RISC-V CPU Micro-architecture (Day 4) </summary>

# **LAB SESSION 6:**

### BLOCK DIAGRAM:
![Screenshot 2024-08-22 011655](https://github.com/user-attachments/assets/d70f3744-d31c-4821-8120-62e87e508de4)

#### 1. Program Counter(PC) and next PC Logic:
The Program Counter (PC) is a critical component in a RISC-V CPU (and any CPU in general), responsible for keeping track of the address of the next instruction to be executed. Understanding the role and implementation of the PC is fundamental when designing or working with a RISC-V CPU.

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])
   
\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         $pc[31:0] = $reset ? '0 : >>1$pc + 32'd4;
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 014128](https://github.com/user-attachments/assets/6dbf1a5e-64c0-4370-aa7b-5ea1d50883de)

#### 2. Instruction Fetch:
Instruction fetch is the first stage in the instruction execution cycle of a RISC-V CPU. It involves retrieving the instruction pointed to by the Program Counter (PC) from memory so that it can be decoded and executed in subsequent stages.

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   //  This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])
   
\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         $pc[31:0] = $reset ? '0 : >>1$pc + 32'd4;
         
         $imem_rd_en = !$reset ? 1 : 0;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $instr[31:0] = $imem_rd_data[31:0];
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 014545](https://github.com/user-attachments/assets/2266bded-d5b0-42cc-9b20-281ada27c12c)

#### 3. Instruction Decode:
Instruction decode is the second stage in the instruction execution cycle of a RISC-V CPU. After an instruction is fetched from memory, it needs to be interpreted, or "decoded," to understand what operation is to be performed and which operands are involved. The decoding process involves breaking down the binary instruction into its constituent fields, such as opcode, source registers, destination registers, and immediate values.

6 Types of Instructions
- **R-type**: Register
- **I-type:** Immediate
- **S-type:** Store
- **B-type:** Branch (Conditional Jump)
- **U-type:** Upper Immediate
- **J-type:** Jump (Unconditional Jump)

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
  m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         //NEXT PC
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
         
         //INSTRUCTION FETCH
      @1
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;
            
            
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         
         //INSTRUCTION DECODE
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 020157](https://github.com/user-attachments/assets/51ae8ab2-2247-4971-84f6-1128733c4bc5)

#### 4. Register File Read:
The read register file is a component that contains a collection of registers used to store data during instruction execution. Instructions typically involve accessing data from these registers, with the instruction indicating which registers to read. The retrieved data is then used as operands for operations carried out by the ALU or other CPU components.

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         //NEXT PC
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
         
         //INSTRUCTION FETCH
      @1
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
        
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         
          //INSTRUCTION DECODE
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits[10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         
         //REGISTER FILE READ
         $rf_wr_en = 1'b0;
         $rf_wr_index[4:0] = 5'b0;
         $rf_wr_data[31:0] = 32'b0;
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUPUT WAVEFORM:
![Screenshot 2024-08-22 015801](https://github.com/user-attachments/assets/6156f787-ae12-4da1-a938-77044f979bcb)

#### 5. Arithmetic Logic Unit (ALU):
The Arithmetic Logic Unit (ALU) in a RISC-V CPU is a key component responsible for performing arithmetic and logical operations. The ALU receives inputs from the register file or immediate values from instructions and produces results that are either stored back into registers, used for branching decisions, or forwarded to other components like memory.

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])
\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = clk;
         //NEXT PC
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
         
         //INSTRUCTION FETCH
      @1
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $opcode[6:0] = $instr[6:0];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         
         //INSTRUCTION DECODE
         $dec_bits[10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         
         //REGISTER FILE READ
         $rf_wr_en = 1'b0;
         $rf_wr_index[4:0] = 5'b0;
         $rf_wr_data[31:0] = 32'b0;
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
         //ARITHMETIC AND LOGIC UNIT (ALU)
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 020723](https://github.com/user-attachments/assets/83e6d934-282c-4b38-ac76-579b56d94438)

#### 6. Register File Write:
 In a RISC-V CPU, the register file write operation is a critical part of the instruction execution process, particularly during the write-back stage of the pipeline. This is where the results of computations or data from memory are written back to a register in the register file

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])
   

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         
         //NEXT PC
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
         
         //INSTRUCTION FETCH
      @1
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $opcode[6:0] = $instr[6:0];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         
         //INSTRUCTION DECODE
         $dec_bits[10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         
         //REGISTER FILE READ         
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
         //ARITHMETIC AND LOGIC UNIT (ALU)
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
         //REGISTER FILE WRITE
         $rf_wr_en = $rd_valid && $rd != 5'b0;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $result;
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 021046](https://github.com/user-attachments/assets/ed170b52-ed9e-413c-acd6-3362cb73e702)

#### 7. Branch Instructions:
The final step is to incorporate support for branch instructions. In the RISC-V ISA, branches are conditional, meaning that a branch is executed only if a specific condition is met. Additionally, the branch target address (PC) must be calculated, and if the branch condition is satisfied, the PC is updated to this new branch target address. This ensures that the program counter correctly points to the intended instruction when a branch is taken.

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         //MODIFIED NEXT PC LOGIC FOR INCLUDING BRANCH INSTRCUTIONS
         $pc[31:0] = >>1$reset ? 32'b0 :
                     >>1$taken_branch ? >>1$br_target_pc :
                     >>1$pc + 32'd4;
         
         //INSTRUCTION FETCH
      @1
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $opcode[6:0] = $instr[6:0];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         
         //INSTRUCTION DECODE
         $dec_bits[10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         
         //REGISTER FILE READ         
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
         //ARITHMETIC AND LOGIC UNIT (ALU)
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
         //REGISTER FILE WRITE
         $rf_wr_en = $rd_valid && $rd != 5'b0;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $result;
         
         //BRANCH INSTRUCTIONS 1
         $taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;
         `BOGUS_USE($taken_branch)
         
         //BRANCH INSTRUCTIONS 2
         $br_target_pc[31:0] = $pc +$imm;
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 021718](https://github.com/user-attachments/assets/f6e38222-2048-4fa1-a9a9-c8ff333d740b)

The overall diagram looks as following:
![Screenshot 2024-08-22 022342](https://github.com/user-attachments/assets/9a0fdff2-ac3b-4db0-945e-a07e3fa1e6b7)

</details>


***

<details>
  <summary>LAB 7: Complete RISC-V CPU Micro-architecture (Day 5) </summary>

# **LAB SESSION 7:**

## Pipelining the CPU
The CPU core now supports pipelining, which simplifies retiming and significantly reduces functional bugs. Pipelining also enables faster computation. As mentioned earlier, implementing pipelining is straightforward by adding @1, @2, and so on. The pipelining snapshot is shown below. In TL Verilog, there's no need to define the pipeline in a strict order.

### 3-Cycle Valid Signal:

```
$valid = $reset ? 1'b0 : ($start) ? 1'b1 : (>>3$valid) ;
        $start_int = $reset ? 1'b0 : 1'b1;
        $start = $reset ? 1'b0 : ($start_int && !>>1$start_int);
```

### Generating valid signals for each instruction:

```
  //Generate valid signals for each instruction fields
         $rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         $rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
         $rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct7_valid           = $is_r_instr;
```

## Completing the RISCV CPU

### Block Diagram:
![Screenshot 2024-08-22 024642](https://github.com/user-attachments/assets/f6fe0d4a-cb05-4348-a13c-673d08ed6ff3)

### CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // Template code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 0 to 9 Program |
   // \====================/
   //
   // Add 0,1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 10000)           // Store r10 result in dmem
   m4_asm(LW, r17, r0, 10000)           // Load contents of dmem to r17
   m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         
         //PC fetch - branch, jumps and loads introduce 2 cycle bubbles in this pipeline
         $pc[31:0] = >>1$reset ? '0 : (>>3$valid_taken_br ? >>3$br_tgt_pc :
                                       >>3$valid_load     ? >>3$inc_pc[31:0] :
                                       >>3$jal_valid      ? >>3$br_tgt_pc :
                                       >>3$jalr_valid     ? >>3$jalr_tgt_pc :
                                                     (>>1$inc_pc[31:0]));
         // Access instruction memory using PC
         $imem_rd_en = ~ $reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         
         
      @1
         //Getting instruction from IMem
         $instr[31:0] = $imem_rd_data[31:0];
         
         //Increment PC
         $inc_pc[31:0] = $pc[31:0] + 32'h4;
         
         //Decoding I,R,S,U,B,J type of instructions based on opcode [6:0]
         //Only [6:2] is used here because this implementation is for RV64I which does not use [1:0]
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] == 5'b11001;
         
         $is_r_instr = $instr[6:2] == 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] == 5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_b_instr = $instr[6:2] == 5'b11000;
         
         $is_j_instr = $instr[6:2] == 5'b11011;
         
         //Immediate value decode
         $imm[31:0] = $is_i_instr ? { {21{$instr[31]}} , $instr[30:20]} :
                      $is_s_instr ? { {21{$instr[31]}} , $instr[30:25] , $instr[11:8] , $instr[7]} :
                      $is_b_instr ? { {20{$instr[31]}} , $instr[7] , $instr[30:25] , $instr[11:8] , 1'b0} :
                      $is_u_instr ? { $instr[31] , $instr[30:12] , { 12{1'b0}} } :
                      $is_j_instr ? { {12{$instr[31]}} , $instr[19:12] , $instr[20] , $instr[30:21] , 1'b0} :
                      >>1$imm[31:0];
         
         //Generate valid signals for each instruction fields
         $rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         $rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
         $rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct7_valid           = $is_r_instr;
         
         //Decode other fields of instruction - source and destination registers, funct, opcode
         ?$rs1_or_funct3_valid
            $rs1[4:0]    = $instr[19:15];
            $funct3[2:0] = $instr[14:12];
         
         ?$rs2_valid
            $rs2[4:0]    = $instr[24:20];
         
         ?$rd_valid
            $rd[4:0]     = $instr[11:7];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         //Decode instruction in subset of base instruction set based on RISC-V 32I
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         //Branch instructions
         $is_beq   = $dec_bits ==? 11'bx_000_1100011;
         $is_bne   = $dec_bits ==? 11'bx_001_1100011;
         $is_blt   = $dec_bits ==? 11'bx_100_1100011;
         $is_bge   = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu  = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu  = $dec_bits ==? 11'bx_111_1100011;
         
         //Jump instructions
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal   = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr  = $dec_bits ==? 11'bx_000_1100111;
         
         //Arithmetic instructions
         $is_addi  = $dec_bits ==? 11'bx_000_0010011;
         $is_add   = $dec_bits ==  11'b0_000_0110011;
         $is_lui   = $dec_bits ==? 11'bx_xxx_0110111;
         $is_slti  = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_xori  = $dec_bits ==? 11'bx_100_0010011;
         $is_ori   = $dec_bits ==? 11'bx_110_0010011;
         $is_andi  = $dec_bits ==? 11'bx_111_0010011;
         $is_slli  = $dec_bits ==? 11'b0_001_0010011;
         $is_srli  = $dec_bits ==? 11'b0_101_0010011;
         $is_srai  = $dec_bits ==? 11'b1_101_0010011;
         $is_sub   = $dec_bits ==? 11'b1_000_0110011;
         $is_sll   = $dec_bits ==? 11'b0_001_0110011;
         $is_slt   = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu  = $dec_bits ==? 11'b0_011_0110011;
         $is_xor   = $dec_bits ==? 11'b0_100_0110011;
         $is_srl   = $dec_bits ==? 11'b0_101_0110011;
         $is_sra   = $dec_bits ==? 11'b1_101_0110011;
         $is_or    = $dec_bits ==? 11'b0_110_0110011;
         $is_and   = $dec_bits ==? 11'b0_111_0110011;
         
         //Store instructions
         $is_sb    = $dec_bits ==? 11'bx_000_0100011;
         $is_sh    = $dec_bits ==? 11'bx_001_0100011;
         $is_sw    = $dec_bits ==? 11'bx_010_0100011;
         
         //Load instructions - support only 4 byte load
         $is_load  = $dec_bits ==? 11'bx_xxx_0000011;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         //Get Source register values from reg file
         $rf_rd_en1 = $rs1_or_funct3_valid;
         $rf_rd_en2 = $rs2_valid;
         
         $rf_rd_index1[4:0] = $rs1[4:0];
         $rf_rd_index2[4:0] = $rs2[4:0];
         
         //Register file bypass logic - data forwarding from ALU to resolve RAW dependence
         $src1_value[31:0] = $rs1_bypass ? >>1$result[31:0] : $rf_rd_data1[31:0];
         $src2_value[31:0] = $rs2_bypass ? >>1$result[31:0] : $rf_rd_data2[31:0];
         
         //Branch target PC computation for branches and JAL
         $br_tgt_pc[31:0] = $imm[31:0] + $pc[31:0];
         
         //RAW dependence check for ALU data forwarding
         //If previous instruction was writing to reg file, and current instruction is reading from same register
         $rs1_bypass = >>1$rf_wr_en && (>>1$rd == $rs1);
         $rs2_bypass = >>1$rf_wr_en && (>>1$rd == $rs2);
         
      @3
         //ALU
         $result[31:0] = $is_addi  ? $src1_value +  $imm :
                         $is_add   ? $src1_value +  $src2_value :
                         $is_andi  ? $src1_value &  $imm :
                         $is_ori   ? $src1_value |  $imm :
                         $is_xori  ? $src1_value ^  $imm :
                         $is_slli  ? $src1_value << $imm[5:0]:
                         $is_srli  ? $src1_value >> $imm[5:0]:
                         $is_and   ? $src1_value &  $src2_value:
                         $is_or    ? $src1_value |  $src2_value:
                         $is_xor   ? $src1_value ^  $src2_value:
                         $is_sub   ? $src1_value -  $src2_value:
                         $is_sll   ? $src1_value << $src2_value:
                         $is_srl   ? $src1_value >> $src2_value:
                         $is_sltu  ? $sltu_rslt[31:0]:
                         $is_sltiu ? $sltiu_rslt[31:0]:
                         $is_lui   ? {$imm[31:12], 12'b0}:
                         $is_auipc ? $pc + $imm:
                         $is_jal   ? $pc + 4:
                         $is_jalr  ? $pc + 4:
                         $is_srai  ? ({ {32{$src1_value[31]}} , $src1_value} >> $imm[4:0]) :
                         $is_slt   ? (($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0, $src1_value[31]}):
                         $is_slti  ? (($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0, $src1_value[31]}) :
                         $is_sra   ? ({ {32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $is_load  ? $src1_value +  $imm :
                         $is_s_instr ? $src1_value + $imm :
                                    32'bx;
         
         $sltu_rslt[31:0]  = $src1_value <  $src2_value;
         $sltiu_rslt[31:0] = $src1_value <  $imm;
         
         //Jump instruction target PC computation
         $jalr_tgt_pc[31:0] = $imm[31:0] + $src1_value[31:0]; 
         
         //Branch resolution
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) :
                     1'b0;
         
         //Current instruction is valid if one of the previous 2 instructions were not (taken_branch or load or jump)
         $valid = ~(>>1$valid_taken_br || >>2$valid_taken_br || >>1$is_load || >>2$is_load || >>2$jump_valid || >>1$jump_valid);
         
         //Current instruction is valid & is a taken branch
         $valid_taken_br = $valid && $taken_br;
         
         //Current instruction is valid & is a load
         $valid_load = $valid && $is_load;
         
         //Current instruction is valid & is jump
         $jump_valid = $valid && $is_jump;
         $jal_valid  = $valid && $is_jal;
         $jalr_valid = $valid && $is_jalr;
         
         //Destination register update - ALU result or load result depending on instruction
         $rf_wr_en = (($rd != '0) && $rd_valid && $valid) || >>2$valid_load;
         $rf_wr_index[4:0] = $valid ? $rd[4:0] : >>2$rd[4:0];
         $rf_wr_data[31:0] = $valid ? $result[31:0] : >>2$ld_data[31:0];
         
      @4
         //Data memory access for load, store
         $dmem_addr[3:0]     =  $result[5:2];
         $dmem_wr_en         =  $valid && $is_s_instr;
         $dmem_wr_data[31:0] =  $src2_value[31:0];
         $dmem_rd_en         =  $valid_load;
         
      
         //Write back data read from load instruction to register
         $ld_data[31:0]      =  $dmem_rd_data[31:0];
         
      
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //Checks if sum of numbers from 1 to 9 is obtained in reg[17] and runs 10 cycles extra after this is met
   *passed = |cpu/xreg[17]>>10$value == (1+2+3+4+5+6+7+8+9);
   //Run for 200 cycles without any checks
   //*passed = *cyc_cnt > 200;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

### SIMULATION STATUS:
![Screenshot 2024-08-22 025131](https://github.com/user-attachments/assets/62f9106b-c0e3-481a-b61b-1e55d8c4e66f)

### BLOCK DIAGRAM:
![Screenshot 2024-08-22 025207](https://github.com/user-attachments/assets/ac19e81c-c167-43a6-ba7d-694567ff87c4)

### VIZ.:
![Screenshot 2024-08-22 025222](https://github.com/user-attachments/assets/cac7a415-6c5a-4d32-b38d-04cd806fb404)

### WAVEFORM:
![Screenshot 2024-08-22 025402](https://github.com/user-attachments/assets/8a31629e-930f-4dd4-8570-0a926708d1a7)

### FINAL OUTPUT WAVEFORM:
![Screenshot 2024-08-22 140254](https://github.com/user-attachments/assets/d76950f0-7253-4f86-98d9-159be1b14c26)


</details>


***


<details>
  <summary>LAB 8: Conversion from TL-Verilog into Verilog using Sandpiper-SaaS compiler. </summary>

# **LAB SESSION 8:**
We originally designed the RISC-V processor using TL-Verilog in the Makerchip IDE. To deploy this design onto an FPGA, we needed to convert the TL-Verilog code into standard Verilog. We successfully carried out this conversion using the Sandpiper-SaaS compiler, which facilitated the transition from high-level TL-Verilog to the more widely used Verilog language, suitable for FPGA implementation. After the conversion, we perform pre-synthesis simulations using the GTKWave simulator to thoroughly verify the functionality and correctness of the design before proceeding to the synthesis and hardware deployment stages. These simulations are crucial for ensuring that the design behaves as expected in a real hardware environment.

### **STEP BY STEP PROCESS:**

#### **STEP 1:** Install required packages
```
sudo apt install make python python3 python3-pip git iverilog gtkwave
sudo apt-get install python3-venv
python3 -m venv .venv
source ~/.venv/bin/activate
pip3 install pyyaml clicksandpiper-saas
```

#### **STEP 2:** Clone the given Github repository and go to VSDbabySoc folder
```
git clone https://github.com/manili/VSDBabySoC.git
cd VSDBabySoc
```
![Screenshot 2024-08-27 023606](https://github.com/user-attachments/assets/c69c030e-c6a8-413a-b48f-3f87b4e42ac1)

#### **STEP 3:** Replace the .tlv file in the VSDBabySoC/src/module directory with the RISC-V .tlv file that we intend to convert into Verilog

#### **STEP 4:** Convert the RISC-V .tlv file into a .v Verilog file by executing the following command:
```
sandpiper-saas -i /home/vsduser/VSDBabySoC/shruti_rvmyth.tlv -o shruti_rvmyth.v --bestsv --noline -p verilog --outdir /home/vsduser/VSDBabySoC/
```

#### **STEP 5:** Now create the pre_synth_sim.vcd by executing the following command:
```
make pre_synth_sim
```

#### **STEP 6:** Compile and simulate the RISC-V design using the following command:
```
iverilog -o output/pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module
cd output
./pre_synth_sim.out
```

#### **STEP 7:** To open the Simulation file in gtkwave tool, run the following command:
```
gtkwave pre_synth_sim.vcd
```

By following these steps, we will successfully convert a RISC-V .tlv file into Verilog and simulate the design using Icarus Verilog and GTKWave.

### **GTKWave Output Waveform:**
![lab8](https://github.com/user-attachments/assets/99e04e18-309e-467a-9df7-4371c88f454d)

**Signals in the Diagram:**

1) clk_shru: Clock input to the RISC-V core.
2) reset: Input reset signal to the RISC-V core.
3) OUT[9:0]: 10-bit output port of the RISC-V core.

### **Makerchip Output Waveform:**
![Screenshot 2024-08-27 023111](https://github.com/user-attachments/assets/a432a45b-c511-445c-893a-a39bd5844086)

### **CONCLUSION:**
The output showing the sum of integers from 1 to 9 is 02D in the waveforms of both Makerchip and GTKWave simulations.

