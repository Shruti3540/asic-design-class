<details>
  <summary>LAB 1: Writing a C program and comparing the outputs compiled with both GCC and the RISC-V compiler. </summary>

# **LAB SESSION 1:**

### **Task 1 : Compiling a C program using GCC and RISC-V**

**STEP 1:** Create a file in editor in Linux environment

![s0](https://github.com/user-attachments/assets/2579e3bb-2e9c-4806-8f93-6601cff88121)

**STEP 2:** Write your code in leafpad and save it

![s1](https://github.com/user-attachments/assets/05d04e05-9b15-4e7c-9616-d45edaaf0f4f)

**STEP 3:** Compile your code using gcc compiler in the terminal window

![s2](https://github.com/user-attachments/assets/2568a685-d390-4f7c-a1e1-910578236ce4)

**STEP 4:** Once you've finished compiling your code, the next step is to run the executable file in your terminal to view its output.

![s3](https://github.com/user-attachments/assets/854f0cdd-09a1-45a6-b5eb-9f62a2600b42)

**Final Output along with Code:**

![s4](https://github.com/user-attachments/assets/21afb510-b79e-4b97-a0eb-ba57cc9d2d26)

### **Task 2 : Compile and run a C program using a RISC-V compiler, optimizing the compilation with -O1 and -Ofast**

**STEP 1:** Write a c program sum1ton on leafpad and save it. Enter a command cat sum1ton.c to view its contents in the terminal.

![1](https://github.com/user-attachments/assets/bfcc7bcd-15aa-4342-870f-fa317551bd25)

**STEP 2:** Compile the C program using the RISC-V compiler with **-O1** optimization.

![2](https://github.com/user-attachments/assets/15abca9b-87b6-497d-adcf-1ae24bf3ea99)

**STEP 3:** Now we enter a command that is used to display information about object files. Since that is long list we use less in the command.

![4a](https://github.com/user-attachments/assets/88ad32f1-b2d0-4638-a69a-4fc01eea9023)

**STEP 4:** We are interested in the main section of the information displayed. Therefore we type main and get the following information.

![3](https://github.com/user-attachments/assets/e6cd9366-a5df-4b40-8b4b-da3129cbd927)

**OBSERVATION 1: There are 14 lines of opcode in main section** 

**STEP 5:** Now again compile the same program using RISC - V compiler but now optimise the compilation using **-Ofast** optimization.

![3b](https://github.com/user-attachments/assets/adad17db-ca14-45f4-b8e4-3077b3c09c05)

**STEP 6:** Similar to the step 3 we enter a command and get another list. The main section of ofast looks as shown in the image.

![4](https://github.com/user-attachments/assets/858d515d-f8b5-49b7-af2a-79da66d20a9e)

**OBSERVATION 2: There are 11 lines of opcode in main section**

**Conclusion: We get an optimized compilation using -Ofast.**

</details>



***



<details>
  <summary>LAB 2: Running the object file generated by the RISC-V compiler in the Spike Simulator and debugging with the Spike Debugger.</summary>

# **LAB SESSION 2:**

### **Task 1 : To compile the Object dump file and verify the output with the GCC output from Lab 1.**

**STEP 1:** Compile sum1ton.c (C source file) into sum1ton.o (Object file) for RISC-V with -Ofast optimization.
``` bash
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sumton.o sumton.c
```

**STEP 2:** Get the Object dump using following command.
``` bash
riscv64-unknown-elf-objdump -d sumton.o | less
```
We get the following output:

![2a](https://github.com/user-attachments/assets/3a431303-1d62-4135-9d6d-0b747380d6a6)

**STEP 3:** Execute the compiled sum1ton.o (object file) using Spike.
``` bash
spike pk sumton.o
```
We get the following output:

![2b](https://github.com/user-attachments/assets/643b5ae2-305a-4336-ac65-668a8b5a052d)

### **Task 2 : To debug the main function and observe register values**

**STEP 1:** Run the assembly code in sum1ton.o on the Spike simulator in debug mode.
``` bash
spike -d pk sumton.o
```
To execute until start of main use following command:
```bash
until pc 0 100b0
```
![2c](https://github.com/user-attachments/assets/3411e913-96df-454e-b13f-4f0c434f119c)

**STEP 2:** Run the following Commands and Observe the Register Values.
```bash
reg 0 a2
reg 0 sp
```

**FINAL OUTPUT:**

<img width="715" alt="Screenshot 2024-07-21 234052" src="https://github.com/user-attachments/assets/0191ffa6-1ef5-45de-90b6-aefbdf1f53ef">

</details>



***



<details>
  <summary>LAB 3: All about RISC-V instructions: Their types, Decoding, Simulation.</summary>

# **LAB SESSION 3:** 

### **TASK 1: Identifying Instruction Format**
The task is to identify different types of instructions based on the provided guidelines. This identification is done using a 32-bit code, with each instruction type having its unique format.

### RISC-V Instruction Formats

Instruction formats in RISC-V act as a 'contract' between the assembly language and the hardware. When an assembly instruction is executed, the hardware understands exactly what to do based on this contract. Each instruction type has a specific format, defined by a series of 0s and 1s, that includes details such as the type of operation and the location of data.

#### 1) R-Type (Register)
 R-type instructions handle all arithmetic and logical operations involving three registers. 
 
 The format includes fields for two source registers, one destination register, a function code, and an opcode.

 Instruction format is as follows:

<img width="538" alt="Screenshot 2024-07-28 170104" src="https://github.com/user-attachments/assets/ae16efea-a976-44c2-9ca1-7078d5814a00">

- **funct7 (7 bits):** Function code for additional instruction differentiation.
- **rs2 (5 bits):** Second source register.
- **rs1 (5 bits):** First source register.
- **funct3 (3 bits):** Function code for primary instruction differentiation.
- **rd (5 bits):** Destination register.
- **opcode (7 bits):** Basic operation code for R-type instructions (0110011 for integer operations).

**Examples:** ADD, SUB, OR, XOR

#### 2) I-Type (Immediate)
These instructions perform arithmetic with immediate values, load operations, and certain branch instructions.

I-type instructions involve operations with an immediate value and one or two registers. 

Instruction format is as follows:

<img width="528" alt="Screenshot 2024-07-28 171319" src="https://github.com/user-attachments/assets/0a532019-7b7c-4b33-a5ee-f90a56420177">

- **immediate (12 bits):** Immediate value used for operations.
- **rs1 (5 bits):** Source register.
- **funct3 (3 bits):** Function code for instruction differentiation.
- **rd (5 bits):** Destination register.
- **opcode (7 bits):** Basic operation code for I-type instructions.

#### 3) S-Type (Store)
S-type instructions are used for store operations, where data is stored from a register into memory. 

The format includes fields for two source registers, an immediate value determining the memory offset, a function code, and an opcode.

Instruction format is as follows:

<img width="522" alt="Screenshot 2024-07-28 171843" src="https://github.com/user-attachments/assets/44fee5c1-e67a-42d3-a147-6a634aa6b965">

- **imm[11:5] (7 bits):** Upper 7 bits of the immediate value.
- **rs2 (5 bits):** Second source register (contains the data to be stored).
- **rs1 (5 bits):** First source register (base address register).
- **funct3 (3 bits):** Function code for instruction differentiation.
- **imm[4:0] (5 bits):** Lower 5 bits of the immediate value.
- **opcode (7 bits):** Basic operation code for S-type instructions.

#### 4) B-Type (Branch)
B-type instructions are used for conditional branch operations.

These instructions alter the flow of execution based on comparisons between two registers.

Instruction format is as follows:

<img width="520" alt="Screenshot 2024-07-28 171920" src="https://github.com/user-attachments/assets/4a11d921-b87a-435d-a5e2-2406f7071e11">

- **imm[12] (1 bit):** The 12th bit of the immediate value.
- **imm[10:5] (6 bits):** The 10th to 5th bits of the immediate value.
- **rs2 (5 bits):** Second source register.
- **rs1 (5 bits):** First source register.
- **funct3 (3 bits):** Function code for instruction differentiation.
- **imm[4:1] (4 bits):** The 4th to 1st bits of the immediate value.
- **imm[11] (1 bit):** The 11th bit of the immediate value.
- **opcode (7 bits):** Basic operation code for B-type instructions.

#### 5) U-Type (Upper Immediate)
U-type instructions handle operations involving large immediate values, typically for loading upper immediate values or computing addresses.

Instruction format is as follows:

<img width="518" alt="Screenshot 2024-07-28 171959" src="https://github.com/user-attachments/assets/0a5238e0-9a70-4944-911e-97a7e925e49b">

- **immediate[31:12] (20 bits):** The upper 20 bits of the immediate value.
- **rd (5 bits):** Destination register.
- **opcode (7 bits):** Operation code for U-type instructions.

The immediate value is stored in the upper 20 bits of a 32-bit word, with the lower 12 bits set to zero when used in calculations.

#### 6) J-Type (Jump)
J-type instructions are used for jump operations, allowing for altering the program control flow by jumping to a specified address.

These are typically used for unconditional jumps, such as calling functions or implementing loops.

Instruction format is as follows:

<img width="521" alt="Screenshot 2024-07-28 172109" src="https://github.com/user-attachments/assets/e158ade7-6748-4ba0-9adf-84b5f67d2410">

- **imm[20] (1 bit):** The 20th bit of the immediate value.
- **imm[10:1] (10 bits):** The 10th to 1st bits of the immediate value.
- **imm[11] (1 bit):** The 11th bit of the immediate value.
- **imm[19:12] (8 bits):** The 19th to 12th bits of the immediate value.
- **rd (5 bits):** Destination register where the return address is stored.
- **opcode (7 bits):** Operation code for J-type instructions.

### **TASK 2: Decoding each Instruction Provided**

1) **ADD r8, r9, r10**
  - Opcode: 0110011
  - rd = r8 = 01000
  - rs1 = r9 = 01001
  - rs2 = r10 = 01010
  - funct3: 000
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_01010_01001_000_01000_0110011`

2) **SUB r10, r8, r9**
  - Opcode: 0110011
  - rd = r10 = 01010
  - rs1 = r8 = 01000
  - rs2 = r9 = 01001
  - funct3: 000
  - funct7: 0100000
  - **R-Type**
  - 32-bit Instruction: `0100000_01001_01000_000_01010_0110011`

3) **AND r9, r8, r10**
  - Opcode: 0110011
  - rd = r9 = 01001
  - rs1 = r8 = 01000
  - rs2 = r10 = 01010
  - funct3: 111
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_01010_01000_111_01001_0110011`

4) **OR r8, r9, r5**
  - Opcode: 0110011
  - rd = r8 = 01000
  - rs1 = r9 = 01001
  - rs2 = r5 = 00101
  - funct3: 110
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_00101_01001_110_01000_0110011`

5) **XOR r8, r8, r4**
  - Opcode: 0110011
  - rd = r8 = 01000
  - rs1 = r8 = 01000
  - rs2 = r4 = 00100
  - funct3: 100
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_00100_01000_100_01000_0110011`

6) **SLT r0, r1, r4**
  - Opcode: 0110011
  - rd = r0 = 00000
  - rs1 = r1 = 00001
  - rs2 = r4 = 00100
  - funct3: 010
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_00100_00001_010_00000_0110011`

7) **ADDI r2, r2, 5**
  - Opcode: 0010011
  - rd = r2 = 00010
  - rs1 = r2 = 00010
  - immediate: 000000000101
  - funct3: 000
  - **I-Type**
  - 32-bit Instruction: `000000000101_00010_000_00010_0010011`

8) **SW r2, r0, 4**
  - Opcode: 0100011
  - rs2 = r2 = 00010
  - rs1 = r0 = 00000
  - imm[11:5]: 0000000
  - imm[4:0]: 00100
  - funct3: 010
  - **S-Type**
  - 32-bit Instruction: `0000000_00010_00000_010_00100_0100011`

9) **SRL r6, r1, r1**
  - Opcode: 0110011
  - rd = r6 = 00110
  - rs1 = r1 = 00001
  - rs2 = r1 = 00001
  - funct3: 101
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_00001_00001_101_00110_0110011`

10) **BNE r0, r0, 20**
  - Opcode: 1100011
  - rs1 = r0 = 00000
  - rs2 = r0 = 00000
  - imm[12|10:5|4:1|11]: 0000000 00000 00010 0
  - funct3: 001
  - **B-Type**
  - 32-bit Instruction: `0000000_00000_00000_001_00010_0000000_1100011`

11) **BEQ r0, r0, 15**
  - Opcode: 1100011
  - rs1 = r0 = 00000
  - rs2 = r0 = 00000
  - imm[12|10:5|4:1|11]: 0000000 00000 00001 1
  - funct3: 000
  - **B-Type**
  - 32-bit Instruction: `0000000_00000_00000_000_00001_0000000_1100011`

12) **LW r3, r1, 2**
  - Opcode: 0000011
  - rd = r3 = 00011
  - rs1 = r1 = 00001
  - immediate: 000000000010
  - funct3: 010
  - **I-Type**
  - 32-bit Instruction: `000000000010_00001_010_00011_0000011`
 
13) **SLL r5, r1, r1**
  - Opcode: 0110011
  - rd = r5 = 00101
  - rs1 = r1 = 00001
  - rs2 = r1 = 00001
  - funct3: 001
  - funct7: 0000000
  - **R-Type**
  - 32-bit Instruction: `0000000_00001_00001_001_00101_0110011`
 
### **TASK 3: Executing assembly instructions based on a provided Verilog code within a RISC-V processor.**
Firstly for the provided verilog code there is some variations in the ISA followed by RISCV and the hardcoded ISA. The differences are shown in the table below:

| Operation            | Standard RISC-V ISA | Hardcoded ISA  |
|----------------------|----------------------|----------------|
| ADD R6, R2, R1       | 32'h00110333         | 32'h02208300   |
| SUB R7, R1, R2       | 32'h402083b3         | 32'h02209380   |
| AND R8, R1, R3       | 32'h0030f433         | 32'h0230a400   |
| OR R9, R2, R5        | 32'h005164b3         | 32'h02513480   |
| XOR R10, R1, R4      | 32'h0040c533         | 32'h0240c500   |
| S#LT R1, R2, R4       | 32'h0045a0b3         | 32'h02415580   |
| ADDI R12, R4, 5      | 32'h004120b3         | 32'h00520600   |
| BEQ R0, R0, 15       | 32'h00000f63         | 32'h00f00002   |
| SW R3, R1, 2         | 32'h0030a123         | 32'h00209181   |
| LW R13, R1, 2        | 32'h0020a683         | 32'h00208681   |
| SRL R16, R14, R2     | 32'h0030a123         | 32'h00271803   |
| SLL R15, R1, R2      | 32'h002097b3         | 32'h00208783   |

Now for the custom instructions provided:

| Operation             | RISC-V ISA  | Bit Pattern (RISC-V)              |
|-----------------------|-------------|-----------------------------------|
| ADD r1, r2, r3        | 32'h006100B3 | 0000000 00110 00010 000 00001 0110011 |
| SUB r3, r1, r2        | 32'h40208333 | 0100000 00010 00001 000 00110 0110011 |
| AND r2, r1, r3        | 32'h0230a400 | 0000000 00011 00001 111 00010 0110011 |
| OR r8, r2, r5         | 32'h0030F133 | 0000000 00101 00010 110 01000 0110011 |
| XOR r8, r1, r4        | 32'h0040C433 | 0000000 00100 00001 100 01000 0110011 |
| SLT r10, r2, r4       | 32'h00412633 | 0000000 00100 00010 010 01100 0110011 |
| ADDI r12, r3, 5       | 32'h00508313 | 000000000101 00001 000 00110 0010011  |
| SW r3, r1, 4          | 32'h00205223 | 0000000 00100 00001 010 0100 0100011  |
| SRL r16, r11, r2      | 32'h0025D833 | 0000000 00010 01011 101 10000 0110011 |
| BNE r0, r1, 20        | 32'h02101A63 | 0 000001 00001 00000 001 1010 0 1100011 |
| LW r13, r11, 2        | 32'h000969A1 | 000000000010 01011 010 01101 00001 |
| SLL r15, r11, r2      | 32'h002597B3 | 0000000 00010 01011 001 01111 0110011 |
| BEQ r0, r0, 15        | 32'h00000F63 | 0 000000 00000 00000 000 1111 0 1100011 |

### **TASK 4: RISC-V Functional Simulation**

1. Compile the Verilog Code using the below command

 ```bash
 iverilog -o iiitb_rv32i iiitb_rv32i.v iiitb_rv32i_tb.v
 ```
2. Run this command to execute the test bench and generate a .vcd file:
 ```bash
  vvp iiitb_rv32i_tb
 ```
3. View the Test Bench in GTKWave:
```bash
gtkwave iiitb_rv32i.vcd
```

### The waveforms for the hardcoded instruction is given below:

`ADD R6, R2, R1`

![Screenshot from 2024-07-30 00-26-20](https://github.com/user-attachments/assets/308c3123-c22e-44d4-af43-2412cd0021ba)

`SUB R7, R1, R2`

![Screenshot from 2024-07-30 00-29-19](https://github.com/user-attachments/assets/d0e289ef-0037-4202-9934-c56d78c5e62c)

`AND R8, R1, R3`

![Screenshot from 2024-07-30 00-29-51](https://github.com/user-attachments/assets/a69ed3f1-e370-4440-9d4f-8b6d9efb12bd)

`OR R9, R2, R5`

![Screenshot from 2024-07-30 00-30-35](https://github.com/user-attachments/assets/e471d776-92ae-4e79-9af2-8fcb53fa4fd3)

`XOR R10, R1, R4`

![Screenshot from 2024-07-30 00-31-15](https://github.com/user-attachments/assets/384552c6-5cae-4325-ad13-235590b502d2)

`SLT R1, R2, R4`

![Screenshot from 2024-07-30 00-32-31](https://github.com/user-attachments/assets/d759ccb4-84cf-4921-b55e-1a7af6604074)

`ADDI R12, R4, 5`

![Screenshot from 2024-07-30 00-33-15](https://github.com/user-attachments/assets/7aa8f1eb-63d6-492a-89d1-55f5c546cae8)

`BEQ R0, R0, 15`

![Screenshot from 2024-07-30 00-35-47](https://github.com/user-attachments/assets/90427858-6048-4d6d-ab50-b20ebf70c6b0)

`SW R3, R1, 2`

![Screenshot from 2024-07-30 00-34-39](https://github.com/user-attachments/assets/4fd987cf-0039-4be6-86ab-faf7d4b06533)

`LW R13, R1, 2`

![Screenshot from 2024-07-30 00-35-14](https://github.com/user-attachments/assets/d0d03073-268e-41ec-bf8b-de4d25e06a39)


### Observation:

We observe a variation between bit pattern of RISCV code and hardcoded ISA.


</details>


***


<details>
  <summary>LAB 4: Writing a C program for a simple application that can be compiled using GCC and RISC-V GCC. </summary>

# **LAB SESSION 4:**
In this lab, we are repeating the steps performed in the previous labs, but for a different application.

**APPLICATION : ELEVATOR CONTROLLER** 

The code provided is a simple implementation of an elevator controller in C. It simulates the basic operations of an elevator, including moving between floors, handling user input for destination floors, and providing feedback on the elevator's status. This program models how an elevator tracks its current position, responds to user commands, and manages directional movement to reach the desired floor, making it a fundamental example of how elevator systems work in real-world applications.

### Task 1 : Writing a C code and compiling the program using GCC (O0).

**STEP 1:** Write a C code for the desired application.

```
#include <stdio.h>

int main() {
    int current_floor = 0;
    int destination_floor;

    while (1) {
        printf("Current Floor: %d\n", current_floor);
        printf("Enter the destination floor (0-9): ");
        scanf("%d", &destination_floor);

        if (destination_floor < 0 || destination_floor > 9) {
            printf("Invalid floor!\n");
            continue;
        }

        if (destination_floor > current_floor) {
            printf("Going up...\n");
            for (int i = current_floor; i <= destination_floor; i++) {
                printf("Floor %d\n", i);
            }
        } else if (destination_floor < current_floor) {
            printf("Going down...\n");
            for (int i = current_floor; i >= destination_floor; i--) {
                printf("Floor %d\n", i);
            }
        } else {
            printf("Already at floor %d\n", current_floor);
        }

        current_floor = destination_floor;
    }
    return 0;
}

```

**STEP 2 :** Compile your code using gcc compiler in the terminal window.

```
gcc ElevatorController.c
```

**STEP 3 :** Run the executable file in your terminal to view its output.

![lab 4 1](https://github.com/user-attachments/assets/74ef10db-a01c-42b3-b45a-8a52b34b0b97)

### Task 2 :  Compile and run a C program using a RISC-V compiler, optimizing the compilation with -O1 (O1).

**STEP 1:** Compile using O1 compiler flag use the following command:

```
riscv64-unknown-elf-gcc -O1 -mabi=lp64i -march=rv64i -o ElevatorControllerO1 ElevatorController.c
```

**STEP 2:** ElevatorControllerO1 is the output file after compilation. Output can be seen using the command:

```
spike pk ElevatorControllerO1
```

**STEP 3:** The output is :

![lab 4 2](https://github.com/user-attachments/assets/aa775e37-8023-4652-b0e8-0a2b4093c615)

### Comparing the gcc compiled output and the risc-v output:

![lab 4 3](https://github.com/user-attachments/assets/957ee189-b719-47c9-af6a-0bfb8c4a31b6)

### **OBSERVATION : The output from both the compilation techniques results to same value for similar inputs given.**
## Hence O0=O1


</details>


***

<details>
  <summary>LAB 5: Digital Logic with TL-Verilog using Makerchip (Day 3) </summary>

# **LAB SESSION 5:** 

### Introduction to Makerchip and TL-Verilog:

Makerchip is an online platform and integrated development environment (IDE) that simplifies the design and simulation of digital circuits using TL-Verilog and traditional Verilog. It offers a user-friendly, accessible interface where users can create, simulate, and visualize hardware designs directly in a web browser, eliminating the need for any software installation.

TL-Verilog is a modern hardware description language designed to simplify and accelerate digital design by reducing the verbosity and complexity commonly associated with traditional hardware languages like Verilog and VHDL. 

TL-Verilog enhances design efficiency by adding powerful constructs for pipelines and transactions, making it easier to develop complex digital circuits.

## Combinational Circuit:

### 1. Combinational Calculator :-
The calculator performs four fundamental arithmetic operations: addition, subtraction, multiplication, and division. 

CODE: 
```
$val1[31:0] = $rand1[3:0];
$val2[31:0] = $rand2[3:0];

$sum[31:0]  = $val1[31:0] + $val2[31:0];
$diff[31:0] = $val1[31:0] - $val2[31:0];
$prod[31:0] = $val1[31:0] * $val2[31:0];
$quot[31:0] = $val1[31:0] / $val2[31:0];

$out[31:0]  = $sel[1] ? ($sel[0] ? $quot[31:0] : $prod[31:0])
                      : ($sel[0] ? $diff[31:0] : $sum[31:0]);
```

OUTPUT WAVEFORM:
![5a](https://github.com/user-attachments/assets/f91de9fc-361d-4fb1-8db5-27891a65ed28)

## Sequential Circuit:

A sequential circuit is a type of digital circuit that uses memory components to retain data, enabling it to generate outputs based on both the current inputs and the circuit's prior state.Sequential circuits rely on feedback loops and storage elements like flip-flops or registers to keep track of their internal state over time. This internal state, combined with the present input, influences the circuit's behavior, allowing it to perform tasks that require a history of previous inputs or operations, such as counting, storing data, or sequencing events.

### 2. Free Running Counter :-
The following code acts as a simple free running counter with a reset value of 0. The counter adds integer 1 to $count at each clock. 

CODE:
```
$reset = *reset;
$count[31:0] = $reset ? 0 : (>>1$count + 1);
```

OUTPUT WAVEFORM:
![5b](https://github.com/user-attachments/assets/9b707c4c-b1ed-497d-a4bf-690c29fb694e)

### 3. Sequential Calculator:-
In real world scenarios calculators typically retain the previous result and apply it in the next operation. The sequential calculator follows this approach by feeding the output back as the input for the subsequent calculation. 

CODE:
```
$val1[31:0] = >>1$out;
$val2[31:0] = $rand[3:0]; 
$sum[31:0] =  $val1[31:0] +  $val2[31:0];
$diff[31:0] =  $val1[31:0] -  $val2[31:0];
$prod[31:0] =  $val1[31:0] *  $val2[31:0];
$quot[31:0] =  $val1[31:0] /  $val2[31:0];
$out[31:0] = $reset ? 32'h0 : ($choose[1] ? ($choose[0] ? $quot : $prod):($choose[0] ? $diff : $sum));
```

OUTPUT WAVEFORM:
![5c](https://github.com/user-attachments/assets/d7e8fae2-cdc1-4970-9b6c-cd95bd46a12a)

## Pipelined Logic:

In Transaction-Level Verilog (TL-Verilog), pipelined logic is expressed using constructs that represent data flow through design stages, with each stage corresponding to a clock cycle. This method simplifies sequential logic modeling, as stages automatically manage state propagation. TL-Verilog's pipeline notation allows designers to describe complex operations focused on transaction flow, improving design clarity and maintainability.

### 4. Cycle Calculator:-

![Screenshot 2024-08-22 003543](https://github.com/user-attachments/assets/98339d1f-ea39-49a2-ac3b-3d172ecd4916)

CODE:
```
|calc
      @1
         $clk_tan = *clk;
         $reset = *reset;
         
         
         $val1[31:0] = >>2$out[31:0];
         $val2[31:0] = $rand2[3:0];
         $op[1:0] = $rand3[1:0];
   
         $sum[31:0] = $val1[31:0] + $val2[31:0];
         $diff[31:0] = $val1[31:0] - $val2[31:0];
         $prod[31:0] = $val1[31:0] * $val2[31:0];
         $quot[31:0] = $val1[31:0] / $val2[31:0];
         
         $num = $reset ? 0 : >>1$num+1;
      @2   
         $out[31:0] = ($reset|!$num) ? 32'b0 : (($op[1:0]==2'b00) ? $sum :
                                       ($op[1:0]==2'b01) ? $diff :
                                          ($op[1:0]==2'b10) ? $prod : $quot);
```

OUTPUT WAVEFORM:
![5d](https://github.com/user-attachments/assets/34b2ca1d-b62c-4cde-a8b9-bcc4efb76cc4)

## Validity:

In TL-Verilog, validity is a key concept used to manage data flow through pipelines. It helps ensure that operations are only performed on valid data and prevents the unnecessary processing of invalid or stale data. This concept is essential in pipelined designs, where operations are spread across multiple clock cycles.

### 5. Validity-Cycle Calculator:-

CODE:
```
|calc
    @0
        $clk_tan = *clk;
        $reset = *reset;
    @1 
        $valid = $reset ? 0 : >>1$valid+1;
        $valid_or_reset = $valid || $reset;  
    ?$valid   
        @1          
          $val1[31:0] = >>2$out[31:0];
          $val2[31:0] = $rand2[3:0];
          $op[1:0] = $rand3[1:0];
        
          $sum[31:0] = $val1[31:0] + $val2[31:0];
          $diff[31:0] = $val1[31:0] - $val2[31:0];
          $prod[31:0] = $val1[31:0] * $val2[31:0];
          $quot[31:0] = $val1[31:0] / $val2[31:0];            
    @2   
       $out[31:0] = $valid_or_reset ? (($op[1:0]==2'b00) ? $sum :
                                           ($op[1:0]==2'b01) ? $diff :
                                              ($op[1:0]==2'b10) ? $prod : $quot) : >>1$out[31:0];
```

OUTPUT WAVEFORM:
![5e](https://github.com/user-attachments/assets/62b845ca-ed50-4feb-9f3f-937146113d69)

</details>


***

<details>
  <summary>LAB 6: Basic RISC-V CPU Micro-architecture (Day 4) </summary>

# **LAB SESSION 6:**

### BLOCK DIAGRAM:
![Screenshot 2024-08-22 011655](https://github.com/user-attachments/assets/d70f3744-d31c-4821-8120-62e87e508de4)

#### 1. Program Counter(PC) and next PC Logic:
The Program Counter (PC) is a critical component in a RISC-V CPU (and any CPU in general), responsible for keeping track of the address of the next instruction to be executed. Understanding the role and implementation of the PC is fundamental when designing or working with a RISC-V CPU.

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])
   
\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         $pc[31:0] = $reset ? '0 : >>1$pc + 32'd4;
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 014128](https://github.com/user-attachments/assets/6dbf1a5e-64c0-4370-aa7b-5ea1d50883de)

#### 2. Instruction Fetch:
Instruction fetch is the first stage in the instruction execution cycle of a RISC-V CPU. It involves retrieving the instruction pointed to by the Program Counter (PC) from memory so that it can be decoded and executed in subsequent stages.

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   //  This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])
   
\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         $pc[31:0] = $reset ? '0 : >>1$pc + 32'd4;
         
         $imem_rd_en = !$reset ? 1 : 0;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $instr[31:0] = $imem_rd_data[31:0];
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 014545](https://github.com/user-attachments/assets/2266bded-d5b0-42cc-9b20-281ada27c12c)

#### 3. Instruction Decode:
Instruction decode is the second stage in the instruction execution cycle of a RISC-V CPU. After an instruction is fetched from memory, it needs to be interpreted, or "decoded," to understand what operation is to be performed and which operands are involved. The decoding process involves breaking down the binary instruction into its constituent fields, such as opcode, source registers, destination registers, and immediate values.

6 Types of Instructions
- **R-type**: Register
- **I-type:** Immediate
- **S-type:** Store
- **B-type:** Branch (Conditional Jump)
- **U-type:** Upper Immediate
- **J-type:** Jump (Unconditional Jump)

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
  m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         //NEXT PC
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
         
         //INSTRUCTION FETCH
      @1
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;
            
            
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         
         //INSTRUCTION DECODE
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 020157](https://github.com/user-attachments/assets/51ae8ab2-2247-4971-84f6-1128733c4bc5)

#### 4. Register File Read:
The read register file is a component that contains a collection of registers used to store data during instruction execution. Instructions typically involve accessing data from these registers, with the instruction indicating which registers to read. The retrieved data is then used as operands for operations carried out by the ALU or other CPU components.

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         //NEXT PC
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
         
         //INSTRUCTION FETCH
      @1
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
        
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         
          //INSTRUCTION DECODE
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits[10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         
         //REGISTER FILE READ
         $rf_wr_en = 1'b0;
         $rf_wr_index[4:0] = 5'b0;
         $rf_wr_data[31:0] = 32'b0;
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUPUT WAVEFORM:
![Screenshot 2024-08-22 015801](https://github.com/user-attachments/assets/6156f787-ae12-4da1-a938-77044f979bcb)

#### 5. Arithmetic Logic Unit (ALU):
The Arithmetic Logic Unit (ALU) in a RISC-V CPU is a key component responsible for performing arithmetic and logical operations. The ALU receives inputs from the register file or immediate values from instructions and produces results that are either stored back into registers, used for branching decisions, or forwarded to other components like memory.

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])
\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = clk;
         //NEXT PC
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
         
         //INSTRUCTION FETCH
      @1
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $opcode[6:0] = $instr[6:0];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         
         //INSTRUCTION DECODE
         $dec_bits[10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         
         //REGISTER FILE READ
         $rf_wr_en = 1'b0;
         $rf_wr_index[4:0] = 5'b0;
         $rf_wr_data[31:0] = 32'b0;
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
         //ARITHMETIC AND LOGIC UNIT (ALU)
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 020723](https://github.com/user-attachments/assets/83e6d934-282c-4b38-ac76-579b56d94438)

#### 6. Register File Write:
 In a RISC-V CPU, the register file write operation is a critical part of the instruction execution process, particularly during the write-back stage of the pipeline. This is where the results of computations or data from memory are written back to a register in the register file

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])
   

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         
         //NEXT PC
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
         
         //INSTRUCTION FETCH
      @1
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $opcode[6:0] = $instr[6:0];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         
         //INSTRUCTION DECODE
         $dec_bits[10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         
         //REGISTER FILE READ         
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
         //ARITHMETIC AND LOGIC UNIT (ALU)
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
         //REGISTER FILE WRITE
         $rf_wr_en = $rd_valid && $rd != 5'b0;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $result;
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 021046](https://github.com/user-attachments/assets/ed170b52-ed9e-413c-acd6-3362cb73e702)

#### 7. Branch Instructions:
The final step is to incorporate support for branch instructions. In the RISC-V ISA, branches are conditional, meaning that a branch is executed only if a specific condition is met. Additionally, the branch target address (PC) must be calculated, and if the branch condition is satisfied, the PC is updated to this new branch target address. This ensures that the program counter correctly points to the intended instruction when a branch is taken.

CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         //MODIFIED NEXT PC LOGIC FOR INCLUDING BRANCH INSTRCUTIONS
         $pc[31:0] = >>1$reset ? 32'b0 :
                     >>1$taken_branch ? >>1$br_target_pc :
                     >>1$pc + 32'd4;
         
         //INSTRUCTION FETCH
      @1
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $opcode[6:0] = $instr[6:0];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         
         //INSTRUCTION DECODE
         $dec_bits[10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         
         //REGISTER FILE READ         
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
         //ARITHMETIC AND LOGIC UNIT (ALU)
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
         //REGISTER FILE WRITE
         $rf_wr_en = $rd_valid && $rd != 5'b0;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $result;
         
         //BRANCH INSTRUCTIONS 1
         $taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;
         `BOGUS_USE($taken_branch)
         
         //BRANCH INSTRUCTIONS 2
         $br_target_pc[31:0] = $pc +$imm;
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

OUTPUT WAVEFORM:
![Screenshot 2024-08-22 021718](https://github.com/user-attachments/assets/f6e38222-2048-4fa1-a9a9-c8ff333d740b)

The overall diagram looks as following:
![Screenshot 2024-08-22 022342](https://github.com/user-attachments/assets/9a0fdff2-ac3b-4db0-945e-a07e3fa1e6b7)

</details>


***

<details>
  <summary>LAB 7: Complete RISC-V CPU Micro-architecture (Day 5) </summary>

# **LAB SESSION 7:**

## Pipelining the CPU
The CPU core now supports pipelining, which simplifies retiming and significantly reduces functional bugs. Pipelining also enables faster computation. As mentioned earlier, implementing pipelining is straightforward by adding @1, @2, and so on. The pipelining snapshot is shown below. In TL Verilog, there's no need to define the pipeline in a strict order.

### 3-Cycle Valid Signal:

```
$valid = $reset ? 1'b0 : ($start) ? 1'b1 : (>>3$valid) ;
        $start_int = $reset ? 1'b0 : 1'b1;
        $start = $reset ? 1'b0 : ($start_int && !>>1$start_int);
```

### Generating valid signals for each instruction:

```
  //Generate valid signals for each instruction fields
         $rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         $rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
         $rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct7_valid           = $is_r_instr;
```

## Completing the RISCV CPU

### Block Diagram:
![Screenshot 2024-08-22 024642](https://github.com/user-attachments/assets/f6fe0d4a-cb05-4348-a13c-673d08ed6ff3)

### CODE:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // Template code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 0 to 9 Program |
   // \====================/
   //
   // Add 0,1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 10000)           // Store r10 result in dmem
   m4_asm(LW, r17, r0, 10000)           // Load contents of dmem to r17
   m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_shru = *clk;
         
         //PC fetch - branch, jumps and loads introduce 2 cycle bubbles in this pipeline
         $pc[31:0] = >>1$reset ? '0 : (>>3$valid_taken_br ? >>3$br_tgt_pc :
                                       >>3$valid_load     ? >>3$inc_pc[31:0] :
                                       >>3$jal_valid      ? >>3$br_tgt_pc :
                                       >>3$jalr_valid     ? >>3$jalr_tgt_pc :
                                                     (>>1$inc_pc[31:0]));
         // Access instruction memory using PC
         $imem_rd_en = ~ $reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         
         
      @1
         //Getting instruction from IMem
         $instr[31:0] = $imem_rd_data[31:0];
         
         //Increment PC
         $inc_pc[31:0] = $pc[31:0] + 32'h4;
         
         //Decoding I,R,S,U,B,J type of instructions based on opcode [6:0]
         //Only [6:2] is used here because this implementation is for RV64I which does not use [1:0]
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] == 5'b11001;
         
         $is_r_instr = $instr[6:2] == 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] == 5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_b_instr = $instr[6:2] == 5'b11000;
         
         $is_j_instr = $instr[6:2] == 5'b11011;
         
         //Immediate value decode
         $imm[31:0] = $is_i_instr ? { {21{$instr[31]}} , $instr[30:20]} :
                      $is_s_instr ? { {21{$instr[31]}} , $instr[30:25] , $instr[11:8] , $instr[7]} :
                      $is_b_instr ? { {20{$instr[31]}} , $instr[7] , $instr[30:25] , $instr[11:8] , 1'b0} :
                      $is_u_instr ? { $instr[31] , $instr[30:12] , { 12{1'b0}} } :
                      $is_j_instr ? { {12{$instr[31]}} , $instr[19:12] , $instr[20] , $instr[30:21] , 1'b0} :
                      >>1$imm[31:0];
         
         //Generate valid signals for each instruction fields
         $rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         $rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
         $rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct7_valid           = $is_r_instr;
         
         //Decode other fields of instruction - source and destination registers, funct, opcode
         ?$rs1_or_funct3_valid
            $rs1[4:0]    = $instr[19:15];
            $funct3[2:0] = $instr[14:12];
         
         ?$rs2_valid
            $rs2[4:0]    = $instr[24:20];
         
         ?$rd_valid
            $rd[4:0]     = $instr[11:7];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         //Decode instruction in subset of base instruction set based on RISC-V 32I
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         //Branch instructions
         $is_beq   = $dec_bits ==? 11'bx_000_1100011;
         $is_bne   = $dec_bits ==? 11'bx_001_1100011;
         $is_blt   = $dec_bits ==? 11'bx_100_1100011;
         $is_bge   = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu  = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu  = $dec_bits ==? 11'bx_111_1100011;
         
         //Jump instructions
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal   = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr  = $dec_bits ==? 11'bx_000_1100111;
         
         //Arithmetic instructions
         $is_addi  = $dec_bits ==? 11'bx_000_0010011;
         $is_add   = $dec_bits ==  11'b0_000_0110011;
         $is_lui   = $dec_bits ==? 11'bx_xxx_0110111;
         $is_slti  = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_xori  = $dec_bits ==? 11'bx_100_0010011;
         $is_ori   = $dec_bits ==? 11'bx_110_0010011;
         $is_andi  = $dec_bits ==? 11'bx_111_0010011;
         $is_slli  = $dec_bits ==? 11'b0_001_0010011;
         $is_srli  = $dec_bits ==? 11'b0_101_0010011;
         $is_srai  = $dec_bits ==? 11'b1_101_0010011;
         $is_sub   = $dec_bits ==? 11'b1_000_0110011;
         $is_sll   = $dec_bits ==? 11'b0_001_0110011;
         $is_slt   = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu  = $dec_bits ==? 11'b0_011_0110011;
         $is_xor   = $dec_bits ==? 11'b0_100_0110011;
         $is_srl   = $dec_bits ==? 11'b0_101_0110011;
         $is_sra   = $dec_bits ==? 11'b1_101_0110011;
         $is_or    = $dec_bits ==? 11'b0_110_0110011;
         $is_and   = $dec_bits ==? 11'b0_111_0110011;
         
         //Store instructions
         $is_sb    = $dec_bits ==? 11'bx_000_0100011;
         $is_sh    = $dec_bits ==? 11'bx_001_0100011;
         $is_sw    = $dec_bits ==? 11'bx_010_0100011;
         
         //Load instructions - support only 4 byte load
         $is_load  = $dec_bits ==? 11'bx_xxx_0000011;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         //Get Source register values from reg file
         $rf_rd_en1 = $rs1_or_funct3_valid;
         $rf_rd_en2 = $rs2_valid;
         
         $rf_rd_index1[4:0] = $rs1[4:0];
         $rf_rd_index2[4:0] = $rs2[4:0];
         
         //Register file bypass logic - data forwarding from ALU to resolve RAW dependence
         $src1_value[31:0] = $rs1_bypass ? >>1$result[31:0] : $rf_rd_data1[31:0];
         $src2_value[31:0] = $rs2_bypass ? >>1$result[31:0] : $rf_rd_data2[31:0];
         
         //Branch target PC computation for branches and JAL
         $br_tgt_pc[31:0] = $imm[31:0] + $pc[31:0];
         
         //RAW dependence check for ALU data forwarding
         //If previous instruction was writing to reg file, and current instruction is reading from same register
         $rs1_bypass = >>1$rf_wr_en && (>>1$rd == $rs1);
         $rs2_bypass = >>1$rf_wr_en && (>>1$rd == $rs2);
         
      @3
         //ALU
         $result[31:0] = $is_addi  ? $src1_value +  $imm :
                         $is_add   ? $src1_value +  $src2_value :
                         $is_andi  ? $src1_value &  $imm :
                         $is_ori   ? $src1_value |  $imm :
                         $is_xori  ? $src1_value ^  $imm :
                         $is_slli  ? $src1_value << $imm[5:0]:
                         $is_srli  ? $src1_value >> $imm[5:0]:
                         $is_and   ? $src1_value &  $src2_value:
                         $is_or    ? $src1_value |  $src2_value:
                         $is_xor   ? $src1_value ^  $src2_value:
                         $is_sub   ? $src1_value -  $src2_value:
                         $is_sll   ? $src1_value << $src2_value:
                         $is_srl   ? $src1_value >> $src2_value:
                         $is_sltu  ? $sltu_rslt[31:0]:
                         $is_sltiu ? $sltiu_rslt[31:0]:
                         $is_lui   ? {$imm[31:12], 12'b0}:
                         $is_auipc ? $pc + $imm:
                         $is_jal   ? $pc + 4:
                         $is_jalr  ? $pc + 4:
                         $is_srai  ? ({ {32{$src1_value[31]}} , $src1_value} >> $imm[4:0]) :
                         $is_slt   ? (($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0, $src1_value[31]}):
                         $is_slti  ? (($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0, $src1_value[31]}) :
                         $is_sra   ? ({ {32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $is_load  ? $src1_value +  $imm :
                         $is_s_instr ? $src1_value + $imm :
                                    32'bx;
         
         $sltu_rslt[31:0]  = $src1_value <  $src2_value;
         $sltiu_rslt[31:0] = $src1_value <  $imm;
         
         //Jump instruction target PC computation
         $jalr_tgt_pc[31:0] = $imm[31:0] + $src1_value[31:0]; 
         
         //Branch resolution
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) :
                     1'b0;
         
         //Current instruction is valid if one of the previous 2 instructions were not (taken_branch or load or jump)
         $valid = ~(>>1$valid_taken_br || >>2$valid_taken_br || >>1$is_load || >>2$is_load || >>2$jump_valid || >>1$jump_valid);
         
         //Current instruction is valid & is a taken branch
         $valid_taken_br = $valid && $taken_br;
         
         //Current instruction is valid & is a load
         $valid_load = $valid && $is_load;
         
         //Current instruction is valid & is jump
         $jump_valid = $valid && $is_jump;
         $jal_valid  = $valid && $is_jal;
         $jalr_valid = $valid && $is_jalr;
         
         //Destination register update - ALU result or load result depending on instruction
         $rf_wr_en = (($rd != '0) && $rd_valid && $valid) || >>2$valid_load;
         $rf_wr_index[4:0] = $valid ? $rd[4:0] : >>2$rd[4:0];
         $rf_wr_data[31:0] = $valid ? $result[31:0] : >>2$ld_data[31:0];
         
      @4
         //Data memory access for load, store
         $dmem_addr[3:0]     =  $result[5:2];
         $dmem_wr_en         =  $valid && $is_s_instr;
         $dmem_wr_data[31:0] =  $src2_value[31:0];
         $dmem_rd_en         =  $valid_load;
         
      
         //Write back data read from load instruction to register
         $ld_data[31:0]      =  $dmem_rd_data[31:0];
         
      
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //Checks if sum of numbers from 1 to 9 is obtained in reg[17] and runs 10 cycles extra after this is met
   *passed = |cpu/xreg[17]>>10$value == (1+2+3+4+5+6+7+8+9);
   //Run for 200 cycles without any checks
   //*passed = *cyc_cnt > 200;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```

### SIMULATION STATUS:
![Screenshot 2024-08-22 025131](https://github.com/user-attachments/assets/62f9106b-c0e3-481a-b61b-1e55d8c4e66f)

### BLOCK DIAGRAM:
![Screenshot 2024-08-22 025207](https://github.com/user-attachments/assets/ac19e81c-c167-43a6-ba7d-694567ff87c4)

### VIZ.:
![Screenshot 2024-08-22 025222](https://github.com/user-attachments/assets/cac7a415-6c5a-4d32-b38d-04cd806fb404)

### WAVEFORM:
![Screenshot 2024-08-22 025402](https://github.com/user-attachments/assets/8a31629e-930f-4dd4-8570-0a926708d1a7)

### FINAL OUTPUT WAVEFORM:
![Screenshot 2024-08-22 140254](https://github.com/user-attachments/assets/d76950f0-7253-4f86-98d9-159be1b14c26)


</details>


***


<details>
  <summary>LAB 8: Conversion from TL-Verilog into Verilog using Sandpiper-SaaS compiler. </summary>

# **LAB SESSION 8:**
We originally designed the RISC-V processor using TL-Verilog in the Makerchip IDE. To deploy this design onto an FPGA, we needed to convert the TL-Verilog code into standard Verilog. We successfully carried out this conversion using the Sandpiper-SaaS compiler, which facilitated the transition from high-level TL-Verilog to the more widely used Verilog language, suitable for FPGA implementation. After the conversion, we perform pre-synthesis simulations using the GTKWave simulator to thoroughly verify the functionality and correctness of the design before proceeding to the synthesis and hardware deployment stages. These simulations are crucial for ensuring that the design behaves as expected in a real hardware environment.

### **STEP BY STEP PROCESS:**

#### **STEP 1:** Install required packages
```
sudo apt install make python python3 python3-pip git iverilog gtkwave
sudo apt-get install python3-venv
python3 -m venv .venv
source ~/.venv/bin/activate
pip3 install pyyaml click sandpiper-saas
```

#### **STEP 2:** Clone the given Github repository and go to VSDbabySoc folder
```
git clone https://github.com/manili/VSDBabySoC.git
cd VSDBabySoc
```

#### **STEP 3:** Replace the .tlv file in the VSDBabySoC/src/module directory with the RISC-V .tlv file that we intend to convert into Verilog

#### **STEP 4:** Convert the RISC-V .tlv file into a .v Verilog file by executing the following command:
```
sandpiper-saas -i /home/vsduser/VSDBabySoC/shruti_rvmyth.tlv -o shruti_rvmyth.v --bestsv --noline -p verilog --outdir /home/vsduser/VSDBabySoC/
```

#### **STEP 5:** Now create the pre_synth_sim.vcd by executing the following command:
```
make pre_synth_sim
```

#### **STEP 6:** Compile and simulate the RISC-V design using the following command:
```
iverilog -o output/pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module
cd output
./pre_synth_sim.out
```

#### **STEP 7:** To open the Simulation file in gtkwave tool, run the following command:
```
gtkwave pre_synth_sim.vcd
```

By following these steps, we will successfully convert a RISC-V .tlv file into Verilog and simulate the design using Icarus Verilog and GTKWave.

### **GTKWave Output Waveform:**
![lab8](https://github.com/user-attachments/assets/99e04e18-309e-467a-9df7-4371c88f454d)

**Signals in the Diagram:**

1) clk_shru: Clock input to the RISC-V core.
2) reset: Input reset signal to the RISC-V core.
3) OUT[9:0]: 10-bit output port of the RISC-V core.

### **Makerchip Output Waveform:**

#### Waveform containing clk_shru i.e. personalized clock name
![Screenshot 2024-08-27 073704](https://github.com/user-attachments/assets/eb4c62d8-ec27-4bf9-b837-c36d0aa03d8b)

#### Waveform containing reset signal
![Screenshot 2024-08-27 073744](https://github.com/user-attachments/assets/2522be12-906d-4a3b-b081-e1749d22d20a)

#### Waveform containing contents in xreg14 for each cycle.
![Screenshot 2024-08-27 023111](https://github.com/user-attachments/assets/a432a45b-c511-445c-893a-a39bd5844086)

### **CONCLUSION:**
The output showing the sum of integers from 1 to 9 is 02D in the waveforms of both Makerchip and GTKWave simulations.

</details>


***


<details>
  <summary>LAB 9: Integration of Peripherals for Digital-to-Analog Conversion Using DAC and PLL. </summary>

# **LAB SESSION 9:**

The VSDBabySoC is a compact yet powerful SoC based on the RISCV architecture. It was designed with the primary goal of testing three open-source IP cores together for the first time and calibrating the analog components. The SoC includes an RVMYTH microprocessor, an 8x-PLL for stable clock generation, and a 10-bit DAC for communication with other analog devices.

### Phase-Locked Loop (PLL):

Phase-Locked Loop (PLL) is a feedback control system that generates a signal with a fixed relation to the phase of a reference signal. 
Basic Components:
1) **Phase Detector (PD):** Compares the input signal with the output signal of the voltage-controlled oscillator (VCO) and produces an error signal proportional to the phase difference.
2) **Low Pass Filter (LPF):** Filters the high-frequency components from the phase detector's output, providing a smoother control voltage for the VCO.
3) **Voltage-Controlled Oscillator (VCO):** Generates a periodic signal (usually a sine wave) whose frequency is determined by the control voltage from the LPF.
4) **Feedback Loop:** The output of the VCO is fed back into the phase detector, creating a closed-loop system.

### Digital-to-Analog Converter (DAC)

A Digital-to-Analog Converter (DAC) translates digital signals (usually in binary form) into analog signals, such as voltage or current. This conversion is crucial in systems where digital data must interact with analog devices or be presented in a form perceivable by humans, like in audio or video output.

DACs are widely used in applications such as audio playback, video display, and signal processing.

## Following steps are to be followed:

### STEP 1: Clone this repo: https://github.com/Subhasis-Sahu/BabySoC_Simulation.git using the following command.

```
git clone https://github.com/Subhasis-Sahu/BabySoC_Simulation.git
```
```
cd BabySoC_Simulation
```

![Screenshot from 2024-09-02 22-26-53](https://github.com/user-attachments/assets/a94f3ee0-8502-4764-b259-0169f3eeda24)

### STEP 2: Change the rvmyth.v code from the previous labs. Then run the following commands and obtain output waveform.

```
iverilog -o ./pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module/
```

```
./pre_synth_sim.out
```

```
gtkwave pre_synth_sim.vcd
```

![Screenshot from 2024-09-03 01-59-31](https://github.com/user-attachments/assets/54db4d18-7ae1-4871-8d85-ce4762f3c5ca)

### DATES:

![Screenshot from 2024-09-03 02-00-43](https://github.com/user-attachments/assets/78773587-b16d-4a8c-b62d-d7f150707ac0)

## WAVEFORMS:

![Screenshot from 2024-09-03 01-54-52](https://github.com/user-attachments/assets/684c0fbf-ff53-4996-a546-5122782bf121)

### OBSERVATION:

1) VCO_IN is the input clk reference signal to the PLL module.
2) reset is the reset signal for the RISC-V CPU.
3) CLK is the output clk signal from the PLL module.
4) clk_shru is the clock used by the RISC-V CPU for the operations.
5) OUT [9:0] is the ouput signal from the RISC-V CPU. Here we can observe the sum value from 1 to 9 over multiple clock cycles.
6) OUT is the DAC output signal.


</details>


***


<details>
  <summary>LAB 10: RTL design using Verilog with SKY130 Technology </summary>

  
  <details>
<summary> <h2> DAY 0: Tools Installation </summary>
    
To continue with the labs we need to install the required tools using the following commands:

```
sudo -i
sudo apt-get install git
ls
cd /home/shruti-chaturvedi
mkdir VLSI
cd VLSI
git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
cd sky130RTLDesignAndSynthesisWorkshop/verilog_files
ls
```
The following directories can be observed:

![Screenshot from 2024-10-21 16-12-49](https://github.com/user-attachments/assets/a0746c16-7f29-4377-968e-819f9bb64f3c)

</details>

<details>
<summary> <h2> DAY 1: Introduction to Verilog RTL design and Synthesis </summary>

<details>
<summary>
 <h4> TASK 1: Introduxtion to iVerilog and GTKWave: </summary>

iverilog: Iverilog is an open-source Verilog simulation and synthesis tool that is commonly used for designing and verifying digital circuits described in the Verilog hardware description language (HDL).

GTKwave: GTKWave is a popular open-source waveform viewer that allows to visualize and analyze digital signal waveforms generated during simulations of digital circuits. It is often used in conjunction with simulation tools like IVERILOG to provide a graphical representation of how signals change over time in a digital design.

![image](https://github.com/user-attachments/assets/d7447081-a288-4473-9605-b00c5784f5c1)

The lab involved learning simulation of a ' 2:1 MULTIPLEXER ' using IVerilog and GTKWave.
```
//mux
module good_mux (input i0 , input i1 , input sel , output reg y);
always @ (*)
begin
 if(sel)
        y <= i1;
 else
        y <= i0;
end
endmodule

//testbench
`timescale 1ns / 1ps
    module tb_good_mux;
    reg i0,i1,sel;
    wire y;

    // Instantiate the Unit Under Test (UUT)
    good_mux uut (.sel(sel),.i0(i0),.i1(i1),.y(y));

    initial begin
    $dumpfile("tb_good_mux.vcd");
    $dumpvars(0,tb_good_mux);
    // Initialize Inputs
    sel = 0;
    i0 = 0;
    i1 = 0;
    #300 $finish;
    end

    always #75 sel = ~sel;
    always #10 i0 = ~i0;
    always #55 i1 = ~i1;
    endmodule
```

The commands to simulate the design is as follows:
```
iverilog good_mux.v tb_good_mux.v
./a.out
gtkwave tb_good_mux.vcd
```
![Screenshot from 2024-10-21 17-27-47](https://github.com/user-attachments/assets/5116760b-5c90-4080-a7c7-befbd82ddd12)

Generated output waveform:

![Screenshot from 2024-10-21 17-30-42](https://github.com/user-attachments/assets/ff0894e0-b811-4e24-a9c6-7e1da9ad68fb)

</details>

<details>
<summary>
 <h4> TASK 2: Introduction to Yosys and Logic synthesis: </summary>
Synthesis: Synthesis is nothing but conversion of RTL design which is writeen in verilog or any other HDL into the netlist which gives the interconnection of components.The netlist is then supposed to perform the same function as the corresponding HDL code. Synthesizer is the tool which convert RTL design into the netlist form. One of such tool is Yosys.

Yosys: Yosys aims to converting high-level hardware descriptions into optimized gate-level representations that can be targeted for various FPGA and ASIC technologies. The flow for yosys is we feed the yosys with the design which is in RTL level and the .lib file which contain standard library cells then the yosys synthesizes and gives us the netlist file.

#### Flow of yosys synthesis:
![image](https://github.com/user-attachments/assets/1ef77741-44c9-41f5-a71e-b5e8be28f340)

#### Synthesis verification:
![image](https://github.com/user-attachments/assets/8706dcb7-0d1b-4236-b3d7-5683f36fc2d8)

Commands for yosys:

1. Opens Yosys Tool
```
yosys
```
2. Reads the technology library file (Liberty format) required for synthesis using the specified path.
```
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib      
```
3. Reads the Verilog file good_mux.v for synthesis.
```
read_verilog good_mux.v
```
![Screenshot from 2024-10-21 18-37-48](https://github.com/user-attachments/assets/c9f2ede2-2169-4849-a9c4-d322138db1ad)

4. Synthesize the top level module
```
synth -top good_mux     
```
![Screenshot from 2024-10-21 18-38-07](https://github.com/user-attachments/assets/97a3a1fd-a789-47a4-94c2-146e4f89a516)
![Screenshot from 2024-10-21 18-40-23](https://github.com/user-attachments/assets/8eb35125-f221-4c37-8678-f4cd7bc34d1f)

5. Map to the standard library
```
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
![Screenshot from 2024-10-21 18-40-38](https://github.com/user-attachments/assets/d10ae228-a6ac-43d9-b7d3-85f1b31bcbd1)
![Screenshot from 2024-10-21 18-40-57](https://github.com/user-attachments/assets/1061cb39-3226-4d75-85d7-8926b6e1b90e)

6. Displays the synthesized design as a schematic.
```
show
```
7. Writes the synthesized netlist to the file good_mux_netlist.v without attributes.
```
write_verilog -noattr good_mux_netlist.v
```

![Screenshot from 2024-10-21 18-49-34](https://github.com/user-attachments/assets/d742fecd-3aee-4395-8571-bec6b84a71d1)
![Screenshot from 2024-10-21 18-50-11](https://github.com/user-attachments/assets/885e6d59-23de-42ea-bfc7-41c385add05c)

8. Opens the netlist file good_mux_netlist.v.
```
!gvim good_mux_netlist.v
```

![Screenshot from 2024-10-21 18-54-06](https://github.com/user-attachments/assets/9a6c672e-f343-49c0-a064-2110372b2e96)
![Screenshot from 2024-10-21 18-54-33](https://github.com/user-attachments/assets/d461cda1-cd01-4449-8c45-4a6fb6169111)

</details>

</details>


<details>
<summary> <h2> DAY 2: Timing libs, hierarchical vs flat synthesis and efficient flop coding styles </summary>


<details>
<summary> <h4>TASK 1: Introduction to dot lib: </summary>
'.lib' is like a collection of standard cells. It contains slow cells, fast cells and many more things. In order to view the '.lib' files, Enter the following command :

```
sudo -i
cd /home/chandra-shekhar-jha/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib
gvim sky130_fd_sc_hd__tt_025C_1v80.lib
```

![Screenshot from 2024-10-21 19-38-39](https://github.com/user-attachments/assets/028dc3fd-66d6-43d7-beb7-99f92d95b218)

The `.lib` file contains essential information about the manufacturing process used (e.g., 130nm technology) and process conditions, including temperature, voltage, and other factors. It also outlines various constraints, such as the units for different variables and the specific technology type. For instance:

- `technology("cmos")`: Specifies that the technology is CMOS.
- `delay_model : "table_lookup"`: Defines the delay model used.
- `bus_naming_style : "%s[%d]"`: Sets the naming convention for buses.
- `time_unit : "1ns"`: Defines the unit of time.
- `voltage_unit : "1V"`: Specifies the voltage unit.
- `leakage_power_unit : "1nW"`: Sets the unit for leakage power.
- `current_unit : "1mA"`: Defines the current unit.
- `pulling_resistance_unit : "1kohm"`: Specifies the pulling resistance unit.
- `capacitive_load_unit(1.0000000000, "pf")`: Sets the unit for capacitive load.

Additionally, the `.lib` file provides detailed characteristics for various cells, including information about leakage power, power consumption, area, input capacitance, and delay based on different input conditions.

Different types of AND gates:

![Screenshot from 2024-10-21 20-19-51](https://github.com/user-attachments/assets/99583e36-12bb-4ee4-891c-797435733758)

</details>

<details>
<summary> <h4> TASK 2: Hierarchical vs Flat Synthesis: </summary>
	
#### Hierarchial Synthesis: Hierarchical synthesis in physical design involves breaking down the entire chip design into smaller, manageable modules or blocks. Each module is designed and optimized separately, and then these modules are integrated at a higher level to create the complete chip layout. This approach allows for better control over the design process, reduces complexity, and enables efficient reuse of standardized blocks. All the modules are preserved.

Commands:
 
```
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog multiple_modules.v
```

![Screenshot from 2024-10-21 21-49-25](https://github.com/user-attachments/assets/2ae655e0-f8ec-4731-8d6a-aa8d9d9683cb)

To synthesize the design:
```
synth -top multiple_modules
```

![Screenshot from 2024-10-21 21-58-43](https://github.com/user-attachments/assets/8f16ec8f-acfe-4c89-9989-038197118550)

```
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show multiple_modules
```

![Screenshot from 2024-10-21 22-03-17](https://github.com/user-attachments/assets/9e11bc2c-4688-4bca-bb1a-1790142b04f1)

Now Generate the Netlist:
```
write_verilog -noattr multiple_modules_hier.v
!gvim multiple_modules_hier.v
```

![Screenshot from 2024-10-21 22-13-31](https://github.com/user-attachments/assets/d549a557-6495-4d8f-ac0b-f5b308092a55)

#### Flat Synthesis: Flat synthesis in physical design involves designing the entire chip layout as a single, monolithic entity without explicit hierarchical divisions. This approach treats the entire design as a cohesive unit, potentially resulting in a simpler layout. It flattens out the modules into gates with higher efficiency and performance.

```
flatten
show
```

![Screenshot from 2024-10-21 22-19-54](https://github.com/user-attachments/assets/2418482c-1c10-4969-b9f8-bbd3d1925e0f)

Now Generate the Netlist:
```
write_verilog -noattr multiple_modules_hier.v
!gvim multiple_modules_hier.v
```

![Screenshot from 2024-10-21 22-22-27](https://github.com/user-attachments/assets/163440fe-2ea4-42bf-81b6-1496856fd60c)

</details>

<details>
<summary> <h4> TASK 3: Various Flop Coding Styles and optimization: </summary>

Why do we use flip-flops?

There is a propogation delay in combinational circuits, there is a glitch in the output due to this delay. More the amount of combinational circuits, more is the number of glitches we see. So to overcome this problem in the output of a circuit, we introduce a storage element, a flop, in between the combinational circuits which gives a stable output always.This is because a flop is triggered only on the positive edge of the clock.

Initialisation of the flop is done with the control pins on the flop which are reset/set.

### Simulation of D-Flipflop using Iverilog and GTKWave. Performing simulations for 3 types of D-Flipflops:

- Asynchronous Reset
- Asynchronous Set
- Synchronous Reset

#### 1. Asynchronous reset:

Irrespective of the clk signal, if the reset value is high, flop output comes down to zero.

Verilog code describing D flop with asynchronous reset which is positive edge triggered:
```
module dff_asyncres(input clk, input async_reset, input d, output reg q);
	always@(posedge clk, posedge async_reset)
	begin
		if(async_reset)
			q <= 1'b0;
		else
			q <= d;
	end
endmodule
```
Testbench:
```
module tb_dff_asyncres; 
	reg clk, async_reset, d;
	wire q;
	dff_asyncres uut (.clk(clk),.async_reset (async_reset),.d(d),.q(q));

	initial begin
		$dumpfile("tb_dff_asyncres.vcd");
		$dumpvars(0,tb_dff_asyncres);
		// Initialize Inputs
		clk = 0;
		async_reset = 1;
		d = 0;
		#3000 $finish;
	end
		
	always #10 clk = ~clk;
	always #23 d = ~d;
	always #547 async_reset=~async_reset; 
endmodule
```
Commands in order to see the waveform:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_asyncres.v tb_dff_asyncres.v
ls
./a.out
gtkwave tb_dff_asyncres.vcd
```

![Screenshot from 2024-10-21 22-45-19](https://github.com/user-attachments/assets/24a6d010-da60-400c-887c-d269dd0e5749)

From the waveform, it can be observed that the Q output changes to zero when the asynchronous reset is set high, independent of the positive/negative clock edge.

#### 2. Asynchronous set:

Verilog code describing D flop with asynchronous set:
```
module dff_async_set(input clk, input async_set, input d, output reg q);
	always@(posedge clk, posedge async_set)
	begin
		if(async_set)
			q <= 1'b1;
		else
			q <= d;
	end
endmodule
```
Testbench:
```
module tb_dff_async_set; 
	reg clk, async_set, d;
	wire q;
	dff_async_set uut (.clk(clk),.async_set (async_set),.d(d),.q(q));

	initial begin
		$dumpfile("tb_dff_async_set.vcd");
		$dumpvars(0,tb_dff_async_set);
		// Initialize Inputs
		clk = 0;
		async_set = 1;
		d = 0;
		#3000 $finish;
	end
		
	always #10 clk = ~clk;
	always #23 d = ~d;
	always #547 async_set=~async_set; 
endmodule
```
Commands in order to see the waveform:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_async_set.v tb_dff_async_set.v
ls
./a.out
gtkwave tb_dff_async_set.vcd
```

![Screenshot from 2024-10-21 23-37-07](https://github.com/user-attachments/assets/da3a2d20-e76c-4c49-99d6-48ac309147b1)

From the waveform, it can be observed that the Q output changes to one when the asynchronous set is set high, independent of the positive/negative clock edge.

#### 3. Synchronous Reset:

Verilog code describing D flop with synchronous reset:
```
module dff_syncres(input clk, input sync_reset, input d, output reg q);
	always@(posedge clk)
	begin
		if(sync_reset)
			q <= 1'b0;
		else
			q <= d;
	end
endmodule
```
Testbench:
```
module tb_dff_syncres; 
	reg clk, syncres, d;
	wire q;
	dff_asyncres uut (.clk(clk),.sync_reset (sync_reset),.d(d),.q(q));

	initial begin
		$dumpfile("tb_dff_syncres.vcd");
		$dumpvars(0,tb_dff_syncres);
		// Initialize Inputs
		clk = 0;
		sync_reset = 1;
		d = 0;
		#3000 $finish;
	end
		
	always #10 clk = ~clk;
	always #23 d = ~d;
	always #547 sync_reset=~async_reset; 
endmodule
```
Commands in order to see the waveform:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_syncres.v tb_dff_syncres.v
ls
./a.out
gtkwave tb_dff_syncres.vcd
```

![Screenshot from 2024-10-21 23-52-24](https://github.com/user-attachments/assets/f3c1d017-b58c-4f7e-ae2d-2d7d53619875)

From the waveform, it can be observed that the Q output changes to zero when the synchronous reset is set high, only at the positive clock edge.

### Synthesis of Various D-Flipflop using Yosys. Performing simulations for 3 types of D-Flipflops

- Asynchronous Reset
- Asynchronous Set
- Synchronous Reset

#### 1. Asynchronous reset:

Commands:
```
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog dff_asyncres.v
synth -top dff_asyncres
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 00-00-05](https://github.com/user-attachments/assets/aaa7a235-028f-4e09-965b-36b446b97723)

#### 2. Asynchronous set:

Commands:
```
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog dff_async_set.v
synth -top dff_async_set
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 00-12-36](https://github.com/user-attachments/assets/a09e3a17-e6af-47dd-928a-ba5f025acbb7)

#### 3. Synchronous reset:

Commands:
```
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog dff_syncres.v
synth -top dff_syncres
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 00-18-08](https://github.com/user-attachments/assets/0e38001a-90f2-4f13-9ebd-b958d8742746)

</details>
</details>

<details>
<summary> <h2> DAY 3: Combinational and sequential optmizations </summary>

<details>
<summary> <h4> TASK 1: Optimization of various Combinational Designs: </summary>

Optimization of various Combinational Designs

- 2 input AND gate.
- 2 input OR gate.
- 3 input AND gate.
- 2 input XNOR Gate (3 input Boolean Logic)
- Multiple Module Optimization-1
- Multiple Module Optimization-2

### 1. 2 Input AND Gate:

Verilog Code:
```
module opt_check(input a, input b, output y);
	assign y = a?b:0;
endmodule
```

Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog opt_check.v
synth -top opt_check
```

![Screenshot from 2024-10-22 00-38-27](https://github.com/user-attachments/assets/bcfb80f0-417b-449e-bb0a-45e74fee1afe)

Generate netlist and create graphical representation:
```
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
opt_clean -purge
show
```

![Screenshot from 2024-10-22 00-43-31](https://github.com/user-attachments/assets/a4530fac-6c93-43b6-ae0a-d2b3ef39dd41)

### 2. 2 Input OR Gate:

Verilog Code:
```
module opt_check2(input a, input b, output y);
	assign y = a?1:b;
endmodule
```

Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog opt_check2.v
synth -top opt_check2
```

![Screenshot from 2024-10-22 00-48-10](https://github.com/user-attachments/assets/df3532b6-7034-4c0e-9d9f-aee34d1220fb)

Generate netlist and create graphical representation:
```
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
opt_clean -purge
show
```

![Screenshot from 2024-10-22 00-50-27](https://github.com/user-attachments/assets/3746bae9-6cee-46c2-bf65-711c61fd97c6)

### 3. 3 Input AND Gate:

Verilog Code:
```
module opt_check2(input a, input b, input c, output y);
	assign y = a?(b?c:0):0;
endmodule
```

Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog opt_check3.v
synth -top opt_check3
```

![Screenshot from 2024-10-22 00-54-16](https://github.com/user-attachments/assets/790c13af-e87d-41c8-84e9-812cfafded34)


Generate netlist and create graphical representation:
```
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
opt_clean -purge
show
```

![Screenshot from 2024-10-22 00-56-25](https://github.com/user-attachments/assets/dda93fc9-d187-45d0-a344-3913504237bb)


### 4. 2 input XNOR Gate (3 input Boolean Logic):

Verilog Code:
```
module opt_check2(input a, input b, input c, output y);
	assign y = a ? (b ? ~c : c) : ~c;
endmodule
```

Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog opt_check4.v
synth -top opt_check4
```

![Screenshot from 2024-10-22 00-59-32](https://github.com/user-attachments/assets/cceda327-a4f4-4b1d-82fa-1c06a7f9c6e7)

Generate netlist and create graphical representation:
```
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
opt_clean -purge
show
```

![Screenshot from 2024-10-22 01-00-56](https://github.com/user-attachments/assets/20b19f70-2281-48b0-9103-dd8532caf441)

### 5. Multiple Module Optimization-1:

Verilog Code:
```
module sub_module1(input a, input b, output y);
	assign y = a & b;
endmodule

module sub_module2 (input a, input b output y);
	assign y = a^b;
endmodule

module multiple_module_opt(input a, input b input c, input d output y);
	wire n1,n2, n3;

	sub_module1 U1 (.a(a), .b(1'b1), .y(n1));
	sub_module2 U2 (.a(n1), .b(1'b0), .y(n));
	sub_module2 U3 (.a(b), .b(d), .y(n3));

	assign y = c | (b & n1);
endmodule
```

Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog multiple_module_opt.v
synth -top multiple_module_opt
```

![Screenshot from 2024-10-22 01-04-45](https://github.com/user-attachments/assets/ce96b513-49ed-4ead-9c76-690deb7b2c8f)

Generate netlist and create graphical representation:
```
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
opt_clean -purge
flatten
show
```

![Screenshot from 2024-10-22 01-08-29](https://github.com/user-attachments/assets/c9491732-f67a-42d8-a94f-31ad8b8f82b5)

### 6. Multiple Module Optimization-2:

Verilog Code:
```
module sub_module(input a input b output y);
	assign y = a & b;
endmodule

module multiple_module_opt2(input a, input b input c, input d, output y);
	wire n1,n2, n3;

	sub_module U1 (.a(a), .b(1'b0), y(n));
	sub_module U2 (.a(b), .b(c), .y(n2));
	sub_module U3 (.a(n2), .b(d), .y(n));
	sub_module U4 (.a(n3), .b(n1), .y(y));
endmodule
```

Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog multiple_module_opt2.v
synth -top multiple_module_opt2
```

![Screenshot from 2024-10-22 01-12-34](https://github.com/user-attachments/assets/d290d891-9b1a-4c98-991f-bdf283631e5f)

Generate netlist and create graphical representation:
```
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
opt_clean -purge
flatten
show
```

![Screenshot from 2024-10-22 01-14-17](https://github.com/user-attachments/assets/13c6f0c4-f5c8-4c9d-938a-dcae6215fedd)

</details>

<details>
<summary> <h4> TASK 2: Optimization of various Sequential Designs: </summary>

Optimization of various Sequential Designs

- D-Flipflop Constant 1 with Asynchronous Reset (active low)
- D-Flipflop Constant 2 with Asynchronous Reset (active high)
- D-Flipflop Constant 3 with Synchronous Reset (active low)
- D-Flipflop Constant 4 with Synchronous Reset (active high)
- D-Flipflop Constant 5 with Synchronous Reset
- Counter Optimization 1
- Counter Optimization 2

### 1. D-Flipflop Constant 1 with Asynchronous Reset (active low):

Verilog Code:
```
module dff_const1(input clk, input reset, output reg q); 
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b0;
	else
		q <= 1'b1;
end
endmodule
```

Testbench:
```
module tb_dff_const1; 
	reg clk, reset;
	wire q;

	dff_const1 uut (.clk(clk),.reset(reset),.q(q));

	initial begin
		$dumpfile("tb_dff_const1.vcd");
		$dumpvars(0,tb_dff_const1);
		// Initialize Inputs
		clk = 0;
		reset = 1;
		#3000 $finish;
	end

	always #10 clk = ~clk;
	always #1547 reset=~reset;
endmodule
```

Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const1.v tb_dff_const1.v
ls
./a.out
gtkwave tb_dff_const1.vcd
```

Resultant Waveform:

![Screenshot from 2024-10-22 01-46-01](https://github.com/user-attachments/assets/af5226df-dba0-42e3-be6f-ba4916e0c519)

From the waveform, it can be observed that the Q output is always high when reset is zero, and reset doesn't depend on clock edge.

Synthesis Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog dff_const1.v
synth -top dff_const1
```

![Screenshot from 2024-10-22 01-51-33](https://github.com/user-attachments/assets/262e3f5f-f939-4c9c-9856-62abdefe4b20)

Generate netlist and create graphical representation:
```
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 01-53-59](https://github.com/user-attachments/assets/28d0420d-aa2b-4f26-acfd-f198fff24b4a)

Since reset doesn't depend on clock edge, therefore the D Flip Flop has not been removed.

### 2. D-Flipflop Constant 2 with Asynchronous Reset (active high):

Verilog Code:
```
module dff_const1(input clk, input reset, output reg q); 
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end
endmodule
```

Testbench:
```
module tb_dff_const2; 
	reg clk, reset;
	wire q;

	dff_const2 uut (.clk(clk),.reset(reset),.q(q));

	initial begin
		$dumpfile("tb_dff_const1.vcd");
		$dumpvars(0,tb_dff_const1);
		// Initialize Inputs
		clk = 0;
		reset = 1;
		#3000 $finish;
	end

	always #10 clk = ~clk;
	always #1547 reset=~reset;
endmodule
```

Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const2.v tb_dff_const2.v
ls
./a.out
gtkwave tb_dff_const2.vcd
```

Resultant Waveform:

![Screenshot from 2024-10-22 02-01-45](https://github.com/user-attachments/assets/98ff21ad-895d-4ddf-a12c-00eac45b39b3)

From the waveform, it can be observed that the Q output is always high irrespective of reset.

Synthesis Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog dff_const2.v
synth -top dff_const2
```

![Screenshot from 2024-10-22 02-26-44](https://github.com/user-attachments/assets/737c5251-2af2-4b18-92af-136865c3c308)

None D Flip Flop has been synthesised.

Generate netlist and create graphical representation:
```
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 02-30-30](https://github.com/user-attachments/assets/ffacd6a0-05d5-4275-a9e7-d2bb71f0b8b5)

Since output q doesn't depend on reset edgeand is always 1, therefore the D Flip Flop has been removed.

### 3.  D-Flipflop Constant 3 with Synchronous Reset (active low)

Verilog Code:
```
module dff_const3(input clk, input reset, output reg q); 
	reg q1;

	always @(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q <= 1'b1;
			q1 <= 1'b0;
		end
		else
		begin	
			q1 <= 1'b1;
			q <= q1;
		end
	end
endmodule
```

Synthesis Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog dff_const3.v
synth -top dff_const3
```

![Screenshot from 2024-10-22 02-38-56](https://github.com/user-attachments/assets/8aff8f46-32f9-425f-94bf-e5f3b45a9c95)

Generate netlist and create graphical representation:
```
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 02-41-21](https://github.com/user-attachments/assets/abbf2e38-850d-4645-9a20-7f070c5d012b)

This module defines a D flip-flop, for a positive edge of reset, q is set to 1 and q1 is set to 0. On each clock cycle, q1 is set to 1, and q is updated with the value of q1.

When synthesized, the design will result in a flip-flop where q becomes 1 after the first clock cycle post-reset and stays 1 afterward.

### 4. D-Flipflop Constant 4 with Synchronous Reset (active high)

Verilog Code:
```
module dff_const4(input clk, input reset, output reg q); 
	reg q1;

	always @(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q <= 1'b1;
			q1 <= 1'b1;
		end
		else
		begin	
			q1 <= 1'b1;
			q <= q1;
		end
	end
endmodule
```

Synthesis Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog dff_const4.v
synth -top dff_const4
```

![Screenshot from 2024-10-22 02-49-52](https://github.com/user-attachments/assets/555c4e31-64bf-43a0-93dc-d1825f9f7c7a)

Generate netlist and create graphical representation:
```
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 02-51-52](https://github.com/user-attachments/assets/151becc8-de1b-47a3-89b4-c59c0bb38524)

This module defines a D flip-flop that sets both q and q1 to 1 on a positive edge of reset. On each clock cycle, q1 remains 1, and q is updated with the value of q1 (which is always 1).

When synthesized, the design will result in a flip-flop where q is always 1, regardless of the reset or clock state.

### 5. D-Flipflop Constant 5 with Synchronous Reset

Verilog Code:
```
module dff_const5(input clk, input reset, output reg q); 
	reg q1;

	always @(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q <= 1'b0;
			q1 <= 1'b0;
		end
		else
		begin	
			q1 <= 1'b1;
			q <= q1;
		end
	end
endmodule
```

Synthesis Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog dff_const5.v
synth -top dff_const5
```

![Screenshot from 2024-10-22 02-56-51](https://github.com/user-attachments/assets/756f075d-7162-43bb-b81e-88ee031096d1)

Generate netlist and create graphical representation:
```
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 02-58-31](https://github.com/user-attachments/assets/f8d744f9-b2a2-4ac2-a3c3-6ae8fa4c84b4)

This module defines a D flip-flop that resets both q and q1 to 0 on a positive edge of reset. On each clock cycle, it sets q1 to 1 and then updates q with the value of q1 (which will always be 1 after the first cycle).

When synthesized, the design will result in a flip-flop where q is always 1 after the first clock cycle post-reset.


### 6. Counter Optimization 1

Verilog Code:
```
module counter_opt (input clk, input reset, output q);
	reg [2:0] count;
	assign q = count[0];
	
	always @(posedge clk,posedge reset)
	begin
		if(reset)
			count <= 3'b000;
		else
			count <= count + 1;
	end
endmodule
```

Synthesis Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog counter_opt.v
synth -top counter_opt
```

![Screenshot from 2024-10-22 03-03-07](https://github.com/user-attachments/assets/1963c42c-0f45-4d0b-8801-76f1ef58d8ef)

Generate netlist and create graphical representation:
```
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 03-05-05](https://github.com/user-attachments/assets/7839186d-0fb2-4cb1-8464-c365cca8a7c7)

### 7. Counter Optimization 2

Verilog Code:
```
module counter_opt2 (input clk, input reset, output q);
	reg [2:0] count;
	assign q = (count[2:0] == 3'b100);
	
	always @(posedge clk,posedge reset)
	begin
		if(reset)
			count <= 3'b000;
		else
			count <= count + 1;
	end
endmodule
```

Synthesis Command:
```
sudo -i
cd /home/shruti-chaturvedi/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog counter_opt2.v
synth -top counter_opt2
```

Generate netlist and create graphical representation:
```
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![image](https://github.com/user-attachments/assets/85f1afaf-303e-4e5c-b87a-d7eb02db2ded)

</details>


</details>


<details>
<summary> <h2> DAY 4: GLS, blocking vs non-blocking and Synthesis-Simulation mismatch </summary>

<details>
<summary> <h4> TASK 1: Gate Level Synthesis, Synthesis-Simulation mismatch and Blocking/Non-Blocking statements </summary>

#### Gate-Level Synthesis

GLS is the process of converting a high-level hardware description language (HDL) design (such as Verilog or VHDL) into a gate-level netlist that represents the circuit in terms of basic logic gates like AND, OR, NAND, NOR, flip-flops, etc.

In GLS, we run test bench with netlist as the Design under test instead of the RTL code. Basically, Netlist is logically equal to RTL code as the netlist is obtained by converting RTL code into standard cell gates. We will use GLS to verify the logical correctness of design after synthesis and also to ensure the timing of the design is met. (run with delay annotations.)

#### Why GLS?

To verify the logical correctness of the design after synthesis. Ensuring the timing of the design is met -- For this GLS needs to run with delay annotation.

#### GLS using IVERILOG

Below picture gives an insight of the procedure. Here while using iverilog, we also include gate level verilog models to generate GLS simulation.

![image](https://github.com/user-attachments/assets/c39ad9e0-a0e1-4ea0-946d-d07dd526ff30)

#### Synthesis and Simulation Mismatch

These can happen because of some reasons and few of the are:

1. Missing Sensitivity List
2. Blocking vs Non-Blocking assignments
3. Non-standard verilog coding

To avoid the synthesis and simulation mismatch. It is very important to check the behaviour of the circuit first and then match it with the expected output seen in simulation and make sure there are no synthesis and simulation mismatches. This is why we use GLS.

#### Blocking vs Non-Blocking Assignments

Blocking statements execute the statemetns in the order they are written inside the always block. Non-Blocking statements execute all the RHS and once always block is entered, the values are assigned to LHS. This will give mismatch as sometimes, improper use of blocking statements can create latches.

</details>

<details>
<summary> <h4> TASK 2: Labs on GLS and Synthesis-Simulation Mismatch </summary>

#### EXAMPLE 1:  2 x 1 MUX using ternary operator

Verilog Code:
```
module ternary_operator_mux (input i0 , input i1 , input sel , output y);
assign y = sel?i1:i0;
endmodule
```

Steps for Simulation:
```
iverilog ternary_operator_mux.v tb_ternary_operator_mux.v
./a.out
gtkwave tb_ternary_operator_mux.vcd
```

![Screenshot from 2024-10-22 03-32-17](https://github.com/user-attachments/assets/ddefc855-72db-4a6b-b8db-896959acfe64)

Synthesis Commands:
```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog ternary_operator_mux.v
synth -top ternary_operator_mux
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 03-37-15](https://github.com/user-attachments/assets/7a7474a1-3308-4635-9829-fb6a3c873e56)

Commands for netlist:
```
write_verilog -noattr ternary_operator_mux_net.v
!gvim ternary_operator_mux_net.v
```

![Screenshot from 2024-10-22 03-40-10](https://github.com/user-attachments/assets/47e45d54-d3f7-42bf-aad9-99b4d22c23fb)

Commands for netlist simulation:
```
iverilog ../my_lib/verilog_module/primitives.v ../my_lib/verilog_module/sky130_fd_sc_hd.v ternary_operator_mux_net.v tb_ternary_operator_mux.v
./a.out
gtkwave tb_ternary_operator_mux.vcd
```

![image](https://github.com/user-attachments/assets/861c603b-0ff0-4afb-bffb-d7378594a344)

These waveforms correspond to the GATE LEVEL SYNTHESIS for the Ternary Operator MUX.

#### EXAMPLE 2:  Design of a 2:1 Bad MUX

Verilog Code:
```
module bad_mux(input i0, input i1, input sel, output reg y);
	always@(sel)
	begin
		if(sel)
			y <= i1;
		else
			y <= i0;
	end
endmodule
```

Steps for Simulation:
```
iverilog bad_mux.v tb_bad_mux.v
./a.out
gtkwave tb_bad_mux.vcd
```

![Screenshot from 2024-10-22 03-49-42](https://github.com/user-attachments/assets/0bc0132f-f9b9-4599-8df0-8b75399a553b)

Synthesis Commands:
```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog bad_mux.v
synth -top bad_mux
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
```

![Screenshot from 2024-10-22 03-54-23](https://github.com/user-attachments/assets/a4bf1985-34e4-4295-b1d3-0de8d8e4e028)

Commands for netlist:
```
write_verilog -noattr bad_mux_net.v
!gvim bad_mux_net.v
```

![Screenshot from 2024-10-22 03-56-56](https://github.com/user-attachments/assets/cdc14d04-de77-41dc-9feb-7ca89f4da8c6)


Commands for netlist simulation:
```
iverilog ../my_lib/verilog_module/primitives.v ../my_lib/verilog_module/sky130_fd_sc_hd.v bad_mux_net.v tb_bad_mux.v
./a.out
gtkwave tb_bad_mux.vcd
```

![image](https://github.com/user-attachments/assets/a9dd247a-1cc8-4fe7-ad3c-34cb2ae6ebb8)

These waveforms correspond to the GATE LEVEL SYNTHESIS for the Bad MUX.
</details>

<details>
<summary> <h4> TASK 3: Labs on synth-sim mismatch for blocking statement </summary>


#### EXAMPLE:  Blocking Caveat

Verilog Code:
```
module blocking_caveat (input a , input b , input  c, output reg d); 
reg x;
always @ (*)
	begin
	d = x & c;
	x = a | b;
end
endmodule
```

Steps for Simulation:
```
iverilog blocking_caveat.v tb_blocking_caveat.v
./a.out
gtkwave tb_blocking_caveat.vcd
```

![Screenshot from 2024-10-22 04-08-24](https://github.com/user-attachments/assets/5ee0844d-1436-4b7f-a47f-6658125aa5ca)

As depicted, when A and B go zero, the OR gate output should be zero (X equal to zero), and the AND gate output should also be zero (same as D output). But, the AND gate input of X takes the previous value of A|B equal to one, based on the design created by the blocking statement, hence the discrepancy in the output.

Synthesis Commands:
```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog blocking_caveat.v
synth -top blocking_caveat
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![Screenshot from 2024-10-22 04-19-22](https://github.com/user-attachments/assets/deb09e35-69c9-432b-86be-80bde6a41bbc)

Commands for netlist:
```
write_verilog -noattr blocking_caveat_net.v
!gvim blocking_caveat_net.v
```

![Screenshot from 2024-10-22 04-21-07](https://github.com/user-attachments/assets/2cce787a-022e-49da-ae66-7702584b6143)

Commands for netlist simulation:
```
iverilog ../my_lib/verilog_module/primitives.v ../my_lib/verilog_module/sky130_fd_sc_hd.v blocking_caveat_net.v tb_blocking_caveat.v
./a.out
gtkwave tb_blocking_caveat.vcd
```

![image](https://github.com/user-attachments/assets/efdac88a-4d25-40ab-a7d4-16f5ed785766)

#### Synthesis Simultaion mismatch

![image](https://github.com/user-attachments/assets/9cc8e983-55e1-4e7f-b377-e58c89e74481)

In the second wave window, the netlist simulation demonstrates the correct functioning of the DUT (Design Under Test). In contrast, the first image shows improper behavior of the DUT due to the use of a blocking statement, leading to a synthesis-simulation mismatch. This issue is resolved by performing Gate-Level Simulation (GLS), which verifies the correct behavior in the netlist simulation.

</details>
</details>
